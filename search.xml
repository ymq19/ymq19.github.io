<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端进阶</title>
      <link href="/2021/10/10/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
      <url>/2021/10/10/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack-和-gulp-的区别"><a href="#webpack-和-gulp-的区别" class="headerlink" title="webpack 和 gulp 的区别"></a>webpack 和 gulp 的区别</h2><ul><li><p>gulp 是工具链，构建工具，可以配合各种插件做 JS 压缩，CSS 压缩，less 编译替代手动实现自动化工作。它的主要作用是</p><ol><li>构建工具</li><li>自动化</li><li>提高效率</li></ol></li><li><p>webpack 是文件打包工具，可以把项目的各种 js 文件，css 文件等打包合成一个或多个文件，主要用于模块化方案，预编译模块的方案。它的主要作用是</p><ol><li>打包工具</li><li>自动化</li><li>提高效率</li></ol></li></ul><h2 id="redux-用处"><a href="#redux-用处" class="headerlink" title="redux 用处"></a>redux 用处</h2><p>在组件化的应用中，会有着大量的组件层级关系，深嵌套的组件与浅层父组件进行数据交互，变得十分繁琐困难。而redux，站在一个服务级别的角度，可以毫无阻碍地将应用的状态传递到每一个层级的组件中。redux 就相当于整个应用的管家。</p><h2 id="vue-双向绑定原理"><a href="#vue-双向绑定原理" class="headerlink" title="vue 双向绑定原理"></a>vue 双向绑定原理</h2><p>vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值 (get) 和设置属性值（set）。</p><h2 id="vue-和-react-的区别"><a href="#vue-和-react-的区别" class="headerlink" title="vue 和 react 的区别"></a>vue 和 react 的区别</h2><h3 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h3><ul><li>利用虚拟 DOM 实现快速渲染</li><li>易于继承路由工具，打包工具以及状态管理工具</li><li>优秀的支持和社区</li><li>都是组件化思想，组件化开发</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>vue 基于可变数据，支持双向绑定，采用 template；react 数据是单向的，采用 jsx</li><li>vue 提供了一系列的 api，而 react 的 api 很少</li></ul><h2 id="promise-的状态有哪些"><a href="#promise-的状态有哪些" class="headerlink" title="promise 的状态有哪些"></a>promise 的状态有哪些</h2><p>等待（pending）、已完成（fulfilled）、已拒绝（rejected）</p><h2 id="数据移除第一个元素的方法有哪些"><a href="#数据移除第一个元素的方法有哪些" class="headerlink" title="数据移除第一个元素的方法有哪些"></a>数据移除第一个元素的方法有哪些</h2><p>splice、shift</p><h2 id="vue-中使用-keep-alive-的作用"><a href="#vue-中使用-keep-alive-的作用" class="headerlink" title="vue 中使用 keep-alive 的作用"></a>vue 中使用 keep-alive 的作用</h2><p>使被包含的组件保留状态或避免重新渲染</p><p>特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式，include 表示只在名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存，其中 exclude 的优先级比 include 高</li><li>对应两个钩子函数 activated 和 deactivated，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated</li></ul><h2 id="vue中data为什么要return"><a href="#vue中data为什么要return" class="headerlink" title="vue中data为什么要return"></a>vue中data为什么要return</h2><p>不使用 return 包裹的数据会在项目的全局可见，会造成变量污染；使用 return 包裹的数据中变量只在当前组件中生效，不影响其他组件</p><h2 id="mixins-和-Composition-API-的区别"><a href="#mixins-和-Composition-API-的区别" class="headerlink" title="mixins 和 Composition API 的区别"></a>mixins 和 Composition API 的区别</h2><p>mixins 问题：</p><ul><li>命名冲突</li><li>隐含的依赖关系</li></ul><p>Composition API 取代 mixins</p><ul><li>代码提取，Composition API 很容易提取逻辑</li><li>代码重用，将模块导入到组件中，然后调用</li></ul><h2 id="说说你对-SPA-单页面的理解，它的优缺点是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点是什么？</h2><p>SPA 仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。页面一旦加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p>优点：</p><ul><li>用户体验好，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染</li><li>基于上面一点，SPA 相对于服务器压力小</li><li>前后端职责分离，架构清晰，前端进行交互逻辑。后端负责数据处理</li></ul><p>缺点：</p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上有着天然的劣势</li></ul><h2 id="v-show-与-v-if-有什么区别？"><a href="#v-show-与-v-if-有什么区别？" class="headerlink" title="v-show 与 v-if 有什么区别？"></a>v-show 与 v-if 有什么区别？</h2><p>v-show 是通过设置 DOM 元素的 display 样式属性控制显隐；v-if 是动态的向 DOM 树内添加或删除 DOM 元素。</p><p>v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的。如果在初始渲染时条件为假，则什么都不做，直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show 不管条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p><p>所以 v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h2 id="computed-和-watch-的区别和运用的场景？"><a href="#computed-和-watch-的区别和运用的场景？" class="headerlink" title="computed 和 watch 的区别和运用的场景？"></a>computed 和 watch 的区别和运用的场景？</h2><p>computed：计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值</p><p>watch：监听数据，每当监听的数据变化时，都会执行回调进行后续操作</p><h2 id="谈谈你对-Vue-生命周期的理解"><a href="#谈谈你对-Vue-生命周期的理解" class="headerlink" title="谈谈你对 Vue 生命周期的理解"></a>谈谈你对 Vue 生命周期的理解</h2><p>开始创建、初始化数据、编译模板、挂载 DOM、渲染、更新、渲染、卸载</p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例创建之前，组件属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没生成</td></tr><tr><td>beforeMount</td><td>在挂载开始之前调用，相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>挂载到实例上</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>update</td><td>组件数据更新之后</td></tr><tr><td>activated</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestroy</td><td>组件销毁前调用</td></tr><tr><td>destroyed</td><td>组件销毁后调用</td></tr></tbody></table><h2 id="Vue-组件间通信有哪几种方式？"><a href="#Vue-组件间通信有哪几种方式？" class="headerlink" title="Vue 组件间通信有哪几种方式？"></a>Vue 组件间通信有哪几种方式？</h2><ul><li>父子组件通信：props、$emit</li><li>隔代组件通信：$attrs 和 $listeners、provide 和 inject、eventBus、Vuex</li><li>兄弟组件通信：eventBus、Vuex</li></ul><h2 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h2><p>Proxy 优势：</p><ul><li>Proxy 可以直接监听对象而非属性</li><li>Proxy 可以直接监听数组的变化</li><li>Proxy 有多达 13种拦截方法，不限于 apply、ownKeys、deleteProperty、has 等等 都是 Object.definePeoperty 不具备的</li><li>Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改</li></ul><p>Object.defineProperty 优势：</p><ul><li>兼容性好，支持 IE9</li></ul><h2 id="虚拟-DOM-实现原理"><a href="#虚拟-DOM-实现原理" class="headerlink" title="虚拟 DOM 实现原理"></a>虚拟 DOM 实现原理</h2><ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象</li><li>diff 算法 —— 比较两棵 DOM 树的差异</li><li>pach 算法 —— 将两个虚拟 DOM 对象的差异应用到真实的 DOM 树上</li></ul><h2 id="Vue-中的-key-有什么作用"><a href="#Vue-中的-key-有什么作用" class="headerlink" title="Vue 中的 key 有什么作用"></a>Vue 中的 key 有什么作用</h2><p>key 作为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速。</p><h2 id="Vue-项目的优化"><a href="#Vue-项目的优化" class="headerlink" title="Vue 项目的优化"></a>Vue 项目的优化</h2><p>（1）代码层面的优化</p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历添加 key</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务器渲染 SSR</li></ul><p>（2） webpack 层面的优化</p><ul><li>webpack 对图片的压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><p>（3）基础的 Web 技术的优化</p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2021/10/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/10/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/正则表达式主体/修饰符（可选）</span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 执行对大小写不敏感的匹配</span></span><br><span class="line"><span class="comment">// g 执行全局匹配(查找所有匹配而非在找到第一个匹配后停止)</span></span><br><span class="line"><span class="comment">// m 执行多行匹配</span></span><br></pre></td></tr></table></figure><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>方括号用于查找某个范围内的字符</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[abc]</td><td>查找方括号之间的任何字符</td></tr><tr><td>[^abc]</td><td>查找任何不在方括号之间的字符</td></tr><tr><td>[0-9]</td><td>查找任何从 0 至 9 的数字</td></tr><tr><td>[a-z]</td><td>查找任何从小写 a 到 小写 z 的字符</td></tr><tr><td>[A-Z]</td><td>查找任何从大写 A 到 大写 Z 之间的字符</td></tr><tr><td>[A-z]</td><td>查找任何从大写 A 到 小写 z 之间的字符</td></tr><tr><td>[adgk]</td><td>查找给定集合内的任何字符</td></tr><tr><td>[^adgk]</td><td>查找给定集合外的任何字符</td></tr><tr><td>(red|blue|green)</td><td>查找任何指定的选项</td></tr></tbody></table><p>元字符是拥有特殊含义的字符</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>\d</td><td>查找数字</td></tr><tr><td>\s</td><td>查找空白字符</td></tr><tr><td>\b</td><td>匹配单词边界</td></tr><tr><td>\uxxxx</td><td>查找以十六进制数 xxxx 规定的 Unicode 字符</td></tr><tr><td>.</td><td>查找单个字符，除了换行和行结束符</td></tr><tr><td>\w</td><td>查找数字、字母及下划线</td></tr><tr><td>\W</td><td>查找非单词字母</td></tr><tr><td>\D</td><td>查找非数字字符</td></tr><tr><td>\S</td><td>查找非空白字符</td></tr><tr><td>\B</td><td>查找非单词边界</td></tr><tr><td>\0</td><td>查找 NULL 字符</td></tr><tr><td>\n</td><td>查找换行符</td></tr><tr><td>\f</td><td>查找换页符</td></tr><tr><td>\r</td><td>查找回车符</td></tr><tr><td>\t</td><td>查找制表符</td></tr><tr><td>\v</td><td>查找垂直制表符</td></tr><tr><td>\xxx</td><td>查找八进制 xxx 规定的字符</td></tr><tr><td>\xdd</td><td>查找十六进制 dd 规定的字符</td></tr></tbody></table><p>量词：</p><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>n+</td><td>匹配任何包含至少一个 n 的字符串</td></tr><tr><td>n*</td><td>匹配任何包含零个或多个 n 的字符串</td></tr><tr><td>n?</td><td>匹配任何零个或一个 n 的字符串</td></tr><tr><td>^n</td><td>匹配任何开头为 n 的字符串</td></tr><tr><td>n$</td><td>匹配任何结尾为 n 的字符串</td></tr><tr><td>?=n</td><td>匹配任何其后紧跟接指定字符串 n 的字符串</td></tr><tr><td>?!n</td><td>匹配任何其后没有紧跟指定字符串 n 的字符串</td></tr><tr><td>n{X}</td><td>匹配包含 X 个 n 序列的字符串</td></tr><tr><td>n{X,}</td><td>匹配前面模式 n 连续出现至少 X 次</td></tr><tr><td>n{X, Y}</td><td>前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础知识合集</title>
      <link href="/2021/08/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/"/>
      <url>/2021/08/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="说一下http和https"><a href="#说一下http和https" class="headerlink" title="说一下http和https"></a>说一下http和https</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li>http: 超文本传输协议，互联网上应用最为广泛的一种网络协议，是一个客户端服务器请求和应答的标准（TCP），用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更高效，网络传输减少。</li><li>https: 是以安全为目标的HTTP通道，即HTTP加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</li></ul><h3 id="2-http和https的区别？"><a href="#2-http和https的区别？" class="headerlink" title="2. http和https的区别？"></a>2. http和https的区别？</h3><ul><li><p>http传输的数据都是未加密的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p></li><li><p>https协议需要ca证书，费用较高</p></li><li><p>http是超文本传输协议，信息是明文传输，https则具有安全性的ssl加密传输协议</p></li><li><p>使用不同的链接方式，端口也不同，http协议的端口为80，https的端口为443</p></li><li><p>http连接很简单，是无状态的；https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p></li></ul><h3 id="3-https协议的工作原理"><a href="#3-https协议的工作原理" class="headerlink" title="3. https协议的工作原理"></a>3. https协议的工作原理</h3><ol><li> 客户使用https url 访问服务器，则要求web服务器建立ssl链接</li><li> web服务器接收到客户端的请求后，会将网站的证书，返回或者传输给客户端</li><li>客户端和web服务器端开始协商ssl链接的安全等级，也就是加密等级</li><li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传输给网站</li><li>web服务器端通过自己的私钥解密出会话密钥</li><li>web服务器通过会话密钥加密和客户端之间的通信</li></ol><h3 id="4-https协议的优点"><a href="#4-https协议的优点" class="headerlink" title="4.  https协议的优点"></a>4.  https协议的优点</h3><ul><li>可认证用户和服务器，确保数据发送到正确的客户机和服务器</li><li>比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性</li><li>现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本</li><li>加密的网站在搜索结果中的排名会更高</li></ul><h3 id="5-https协议的缺点"><a href="#5-https协议的缺点" class="headerlink" title="5. https协议的缺点"></a>5. https协议的缺点</h3><ul><li>握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电</li><li>缓存不如http高效，会增加数据开销</li><li>SSL证书也需要钱，功能越强大的证书费用越高</li><li>SSL证书需要绑定IP，不能在同一个IP上绑定多个域名，ipv4资源支持不了这种消耗</li></ul><h2 id="tcp三次握手，一句话概括"><a href="#tcp三次握手，一句话概括" class="headerlink" title="tcp三次握手，一句话概括"></a>tcp三次握手，一句话概括</h2><p><img src="https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tcp握手"></p><p>客户端和服务端都需要直到各自可收发，因此需要三次握手</p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ul><li>TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立连接</li><li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，面向连接，不会丢失数据因此适合大数据量的交换</li><li>TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低</li><li>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多</li><li>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节</li></ul><h2 id="HTTP请求的方式，HEAD方式"><a href="#HTTP请求的方式，HEAD方式" class="headerlink" title="HTTP请求的方式，HEAD方式"></a>HTTP请求的方式，HEAD方式</h2><p>head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头options，允许客户端查看服务器的性能，比如说服务器支持的请求方式等等</p><h2 id="一个图片url访问后直接下载怎样实现？"><a href="#一个图片url访问后直接下载怎样实现？" class="headerlink" title="一个图片url访问后直接下载怎样实现？"></a>一个图片url访问后直接下载怎样实现？</h2><p>请求的返回头里面，用于浏览器解析的重要参数就是 OSS 的 API 文档里面的返回 http 头，决定用户下载行为的参数。</p><p>下载的情况下：</p><ol><li>x-oss-object-type: Normal</li><li>x-oss-request-id: 598D5ED34F29D01FE2925F41</li><li>x-oss-storage-class: Standard</li></ol><h2 id="说一下-web-Quality-（无障碍）"><a href="#说一下-web-Quality-（无障碍）" class="headerlink" title="说一下 web Quality （无障碍）"></a>说一下 web Quality （无障碍）</h2><p>能够被残障人士使用的网站才能称得上一个易用（易访问的）的网站</p><h2 id="几个很实用的BOM属性对象方法？"><a href="#几个很实用的BOM属性对象方法？" class="headerlink" title="几个很实用的BOM属性对象方法？"></a>几个很实用的BOM属性对象方法？</h2><ul><li><p>location对象</p><ul><li>location.href: 返回或设置当前文档的URL</li><li>location.search: 返回URL中的查询字符串内容</li><li>location.hash: 返回URL#后面的内容，如果没有#，返回空</li><li>location.host: 返回URL中的域名部分</li><li>location.hostname: 返回URL的主域名部分</li><li>location.pathname: 返回URL的域名后的部分</li><li>location.port: 返回URL中的端口部分</li><li>location.protocol: 返回URL中的协议部分</li><li>location.assign: 返回当前文档的URL</li><li>location.replace(): 设置当前文档的URL，并且在history对象的地址列表中移除</li><li>location.reload(): 重载当前页面</li></ul></li><li><p>history对象</p><ul><li>history.go(): 前进或后退的页面数</li><li>history.back(): 后退一页</li><li>history.forward(): 前进一页</li></ul></li><li><p>Navigator对象</p><ul><li>navigator.userAgent: 返回用户代理头的字符串表示</li><li>navigator.cookieEnabled: 返回浏览器是否支持（启用）cookie</li></ul></li></ul><h2 id="说一下HTML5-drag-api"><a href="#说一下HTML5-drag-api" class="headerlink" title="说一下HTML5 drag api"></a>说一下HTML5 drag api</h2><ul><li>dragstart: 事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li><li>drag: 事件主体是被拖放元素，在正在拖放被触发元素时触发</li><li>dragenter: 事件主体是目标元素，在被拖放元素进入某元素时触发</li><li>dragover: 事件主体是目标元素，在被拖放在某元素内移动时触发</li><li>dragleave: 事件主体是目标元素，在被拖放元素移出目标元素时出触发</li><li>drop: 事件主体是目标元素，在目标元素完全接收被拖放元素时触发</li><li>dragend: 事件主体是被拖放元素，在整个拖放操作结束时触发</li></ul><h2 id="说一下http2-0"><a href="#说一下http2-0" class="headerlink" title="说一下http2.0"></a>说一下http2.0</h2><p>http2.0是基于1999年发布的http1.0之后的首次更新</p><ul><li>提升访问速度，相比http1.0，请求资源所需时间更少，访问速度更快</li><li>允许多路复用: 多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息</li><li>二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</li><li>首部压缩</li><li>服务器端推送</li></ul><h2 id="补充400和401、403状态码"><a href="#补充400和401、403状态码" class="headerlink" title="补充400和401、403状态码"></a>补充400和401、403状态码</h2><ul><li>400: 请求无效，前端提交的字段名称和字段类型与后台的实体并没有保持一致</li><li>401状态码：当前请求需要用户验证</li><li>403状态码：服务器已经得到请求，但是拒绝执行</li></ul><h2 id="fetch-发送2次请求的原因"><a href="#fetch-发送2次请求的原因" class="headerlink" title="fetch 发送2次请求的原因"></a>fetch 发送2次请求的原因</h2><p>fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码为 204， 第二才成功？</p><p>因为用 fetch 的 post 请求的时候，导致 fetch 第一次发送了一个 OPTIONS 请求，询问服务器是否支持 修改 的请求头，如果服务器支持，则在第二次中发送真正的请求</p><h2 id="说一下-web-worker"><a href="#说一下-web-worker" class="headerlink" title="说一下 web worker"></a>说一下 web worker</h2><p>web worker 是运行在后台的js，独立于其他脚本，不会影响你的性能。并且通过 postMessage 将结果回传到主线程。这样在进行复杂的操作的时候，就不会阻塞主线程了</p><p>创建 web worker：</p><ul><li>检测浏览器对于 web worker 的支持性</li><li>创建 web worker 文件</li><li>创建 web worker 对象</li></ul><h2 id="Cookie-如何预防-XSS-攻击"><a href="#Cookie-如何预防-XSS-攻击" class="headerlink" title="Cookie 如何预防 XSS 攻击"></a>Cookie 如何预防 XSS 攻击</h2><p>XSS （跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 javascript 脚本，为了减轻这些攻击，需要在 HTTP 头部配上 set-cookie: httponly- 这属性可以防止XSS，它会禁止 javascript 脚本来访问 cookie</p><h2 id="一句话概括RESTFUL"><a href="#一句话概括RESTFUL" class="headerlink" title="一句话概括RESTFUL"></a>一句话概括RESTFUL</h2><p>用 URL 定位资源，用 HTTP 描述操作</p><h2 id="addEventListener-参数"><a href="#addEventListener-参数" class="headerlink" title="addEventListener 参数"></a>addEventListener 参数</h2><p>addEventListener(event, function, useCapture)</p><p>其中，event指定事件名；function 指定要事件触发时执行的函数；useCapture 指定事件是否在捕获或冒泡阶段执行</p><h2 id="介绍知道的-http-返回的状态码"><a href="#介绍知道的-http-返回的状态码" class="headerlink" title="介绍知道的 http 返回的状态码"></a>介绍知道的 http 返回的状态码</h2><p><strong>100</strong> Continue 继续。客户端应继续其请求</p><p><strong>101</strong> Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议。</p><p><strong>200</strong> OK 请求成功。一般用于 GET 与 POST 请求</p><p><strong>201</strong> Created 成功请求并创建了新的资源</p><p><strong>202</strong> Accepted 已经接收请求，但未处理而完成</p><p><strong>203</strong> Non-Authoritative Information 非授权请求</p><p><strong>204</strong> No Content 服务器成功处理，但未返回内容</p><p><strong>205</strong> Reset Content 重置内容</p><p><strong>206</strong> Partial Content 服务器成功处理了部分 GET 请求</p><p><strong>300</strong> Multiple Choices 请求的资源可包括多个位置，响应可返回一个资源特征与地址的列表用于用户终端</p><p><strong>301</strong> Moved Permanently 永久移动，今后任何新的请求都应使用新的URI代替</p><p><strong>302</strong> Found 临时移动，客户端应继续使用原有 URI</p><p><strong>303</strong> See Other 查看其他地址</p><p><strong>304</strong> Not Modified 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源</p><p><strong>305</strong> Use Proxy 使用代理</p><p><strong>306</strong> Unused 已经被废弃的 HTTP 状态码</p><p><strong>307</strong> Temporary Redirect 临时重定向</p><p><strong>400</strong> 客户端请求的语法错误，服务器无法理解</p><p><strong>401</strong> Unauthorized 请求要求的用户身份认证</p><p><strong>402</strong> Payment Required 保留，将来使用</p><p><strong>403</strong> Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求</p><p><strong>404</strong> Not Found 服务器无法根据客户端的请求找到资源</p><p><strong>405</strong> Method Not Allowed 客户端的请求方法被禁止</p><p><strong>406</strong> Not Accepted 服务器无法根据客户端请求的内容特性完成请求</p><p><strong>407</strong> Proxy Authentication Required 请求要求代理的身份认证</p><p><strong>408</strong> Request Time-out 服务器等待客户端发送的请求时间过长，超时</p><p><strong>409</strong> Conflict 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突</p><p><strong>410</strong> Gone 客户端的请求资源已经不存在</p><p><strong>411</strong> Length Required 服务器无法处理客户端发送的不带 Content-Length 的请求信息</p><p><strong>412</strong> Precondition Failed 客户端请求信息的先决条件错误</p><p><strong>413</strong> Request Entity Too Large请求的实体过大，服务器无法处理，因此拒绝请求</p><p><strong>414</strong> Request-URI Too Large 请求的 URI 过长，服务器无法处理</p><p><strong>415</strong> Unsupported Media Type 服务器无法处理请求附带的媒体格式</p><p><strong>416</strong> Requested range not satisfiable 客户端请求的范围无效</p><p><strong>417</strong> Expectation Failed 服务器无法满足 Expect 的请求头信息</p><p><strong>500</strong> Internal Server Error 服务器内部错误，无法完成请求</p><p><strong>501</strong> Not Implemented 服务器不支持请求的功能，无法完成请求</p><p><strong>502</strong> Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p><p><strong>503</strong> Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求</p><p><strong>504</strong> Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求</p><p><strong>505</strong> HTTP Version not supported 服务器不支持请求的 HTTP 协议的版本，无法完成处理</p><h2 id="强，协商缓存"><a href="#强，协商缓存" class="headerlink" title="强，协商缓存"></a>强，协商缓存</h2><p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定</p><p>都是从客户端缓存中读取资源，区别是强缓存不会发送请求，协商缓存会发送请求</p><ul><li><strong>强缓存：</strong>不会向服务器发送请求，直接从缓存中读取资源，该请求请求返回200的状态码，相关字段：expires，cache-control，cache-control优先级高于expires</li><li><strong>协商缓存：</strong>向服务器发送请求，服务器会根据这个请求的request header 的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的 response header 通知浏览器从缓存中读取资源 ，相关字段：Last-Modified/If-Modifies-Since，Etag/If-None-Match</li></ul><h2 id="301和302的区别"><a href="#301和302的区别" class="headerlink" title="301和302的区别"></a>301和302的区别</h2><ul><li><strong>301：</strong>永久重定向，常用的场景是域名跳转</li><li><strong>302：</strong>临时重定向，比如未登录用户访问用户中心重定向到登录页面</li></ul><h2 id="HTTP-支持的方法"><a href="#HTTP-支持的方法" class="headerlink" title="HTTP 支持的方法"></a>HTTP 支持的方法</h2><p>GET，POST，HEAD，OPTIONS，PUT，DELETE，TRACE，CONNECT</p><h2 id="浏览器在生成页面时，会生成哪两棵树？"><a href="#浏览器在生成页面时，会生成哪两棵树？" class="headerlink" title="浏览器在生成页面时，会生成哪两棵树？"></a>浏览器在生成页面时，会生成哪两棵树？</h2><p>DOM树和CSSOM规则树，当浏览器接受到服务器相应来的 HTML 文档后，会遍历文档节点，生成 DOM 树。CSSOM树 规则树由浏览器解析 CSS 文件生成。</p><h2 id="怎么看网站的性能如何"><a href="#怎么看网站的性能如何" class="headerlink" title="怎么看网站的性能如何"></a>怎么看网站的性能如何</h2><ul><li>被动检测：在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析</li><li>主动检测：搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析</li></ul><h2 id="多行元素的文本省略号"><a href="#多行元素的文本省略号" class="headerlink" title="多行元素的文本省略号"></a>多行元素的文本省略号</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-orient:vertical;</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;</span><br><span class="line"><span class="attribute">overflow</span>:hidden;</span><br></pre></td></tr></table></figure><h2 id="CSS-动画如何实现"><a href="#CSS-动画如何实现" class="headerlink" title="CSS 动画如何实现"></a>CSS 动画如何实现</h2><p>创建动画序列，需要使用animation属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 @keyframes 规则实现，具体情况参见使用 keyframes 定义动画序列小节部分。transition 也可以实现动画。transition 强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而第二个途径当某种改变发生时才能获取样式，这样就会产生过渡动画。</p><h2 id="display-table-和本身的-table-有什么区别？"><a href="#display-table-和本身的-table-有什么区别？" class="headerlink" title="display: table 和本身的 table 有什么区别？"></a>display: table 和本身的 table 有什么区别？</h2><p>display: table 和本身 table 是相对应的，区别在于，display: table 的 css 声明能够让一个 html 元素和它的子节点像 table 一样，使用基于表格的 css 布局，不会产生因为使用了 table 那样的制表标签导致的语义化问题。用div + css 编写出来的文件比用 table 编写出来的文件小，而且 table 必须在页面完全加载后才显示，div 则是逐行显示，table 的嵌套性太多，没有 div 简洁</p><h2 id="了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法"><a href="#了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法" class="headerlink" title="了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法"></a>了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法</h2><ul><li>重排：DOM 的变化影响到了几何属性比如宽高，浏览器重新计算元素的几何属性，其他元素的几何属性也会收到影响，浏览器需要重新构造渲染树<ol><li>添加、删除可见的dom</li><li>元素的位置改变</li><li>元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）</li><li>页面渲染初始化</li><li>浏览器窗口尺寸改变</li></ol></li><li>重绘：一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观</li></ul><p>减少重绘重排的方法：</p><ul><li>不在布局信息改变时做 DOM 查询</li><li>使用 csstext， className 一次性改变属性</li><li>使用 fragment</li><li>对于多次重拍的元素，使用绝对定位脱离文档流，使其不影响其他元素</li></ul><h2 id="说一下闭包"><a href="#说一下闭包" class="headerlink" title="说一下闭包"></a>说一下闭包</h2><p>闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放</p><h2 id="说一下类的创建和继承"><a href="#说一下类的创建和继承" class="headerlink" title="说一下类的创建和继承"></a>说一下类的创建和继承</h2><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><ol><li><p>类的创建：new 一个 function ，在这个 function 的prototype 里面增加属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name || <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="built_in">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在睡觉&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在吃：&#x27;</span> + food)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的继承</p><ul><li><p>原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line">Cat.prototype.name = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 特点: 基于原型链，既是父类的实例，也是子类的实例</span></span><br><span class="line"><span class="comment">* 缺点：无法实现多继承</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>构造继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.name = name || <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 特点：可以实现多继承</span></span><br><span class="line"><span class="comment">* 缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>组合继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造继承和原型链继承的组合体，通过调用父类构造，继承父类的属性并保留传参的优点，通过将父类实例作为子类原型，实现函数复用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.name = name || <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line">Cat.prototype.constructor = Cat</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 特点：可以继承实例属性、方法，也可以继承原型属性、方法</span></span><br><span class="line"><span class="comment">* 调用了两次构造函数，生成了两份实例</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>寄生组合继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.name = name || <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    Super.prototype = Animal.prototype</span><br><span class="line">    Cat.prototype = <span class="keyword">new</span> Super()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ol><li><p>创建类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的所有方法都定义在类的prototype属性上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x</span><br><span class="line">        <span class="built_in">this</span>.y = y</span><br><span class="line">        <span class="built_in">this</span>.z = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">p</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给对象Person动态增加方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype, &#123;<span class="function"><span class="title">getage</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span>&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure></li><li><p> Class的继承</p></li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 子类必须在constructor方法中调用super方法，否则新建实例时会报错，因为子类没有自己的this对象</span></span><br><span class="line">        <span class="built_in">super</span>(x, y, color)</span><br><span class="line">        <span class="built_in">this</span>.z = <span class="number">3</span></span><br><span class="line">        <span class="comment">// 可以将 super 当作一个对象使用，super作为对象时，指向父类的原型对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.p())</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何解决异步回调地狱"><a href="#如何解决异步回调地狱" class="headerlink" title="如何解决异步回调地狱"></a>如何解决异步回调地狱</h2><blockquote><p>promise</p><p>async / await</p><p>generator</p></blockquote><h2 id="说说前端中的事件流"><a href="#说说前端中的事件流" class="headerlink" title="说说前端中的事件流"></a>说说前端中的事件流</h2><p>DOM 2级事件流：</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><p><img src="https://images.cnitblog.com/blog/37001/201408/141533286861687.png" class="lazyload" data-srcset="https://images.cnitblog.com/blog/37001/201408/141533286861687.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>addEventListener: </p><ul><li>参数：事件名、事件处理程序的函数、布尔值</li><li>布尔值：<ul><li>true：捕获阶段调用事件处理程序</li><li>false：冒泡阶段调用事件处理程序</li></ul></li></ul><h2 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h2><p>DOM 标准事件模型中，先捕获再冒泡。</p><p>对于同一事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件</p><h2 id="说一下事件委托"><a href="#说一下事件委托" class="headerlink" title="说一下事件委托"></a>说一下事件委托</h2><ul><li>简介：不在事件发生地上监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上的事件触发，通过判断事件发生元素DOM的类型，做出不同的响应</li><li>好处：适合动态元素的绑定，新添加的子元素也会有监听函数，也会有事件触发机制</li></ul><h2 id="说一下图片的懒加载和预加载"><a href="#说一下图片的懒加载和预加载" class="headerlink" title="说一下图片的懒加载和预加载"></a>说一下图片的懒加载和预加载</h2><ul><li>预加载：提前加载图片，当用户查看时可直接从本地缓存中渲染</li><li>懒加载：减少请求数或延迟请求数</li></ul><h2 id="mouseover-和-mouseenter-的区别"><a href="#mouseover-和-mouseenter-的区别" class="headerlink" title="mouseover 和 mouseenter 的区别"></a>mouseover 和 mouseenter 的区别</h2><ul><li>mouseover：当鼠标移入元素或其子元素都会触发，所以有一个重复触发，冒泡的阶段。对应的移除事件是 mouseout</li><li>mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，不会冒泡。对应的移除事件是 mouseleave</li></ul><h2 id="js的-new-操作符做了哪些事情"><a href="#js的-new-操作符做了哪些事情" class="headerlink" title="js的 new 操作符做了哪些事情"></a>js的 new 操作符做了哪些事情</h2><p>新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象</p><h2 id="bind，apply，call的区别"><a href="#bind，apply，call的区别" class="headerlink" title="bind，apply，call的区别"></a>bind，apply，call的区别</h2><p>通过apply 和 call 改变函数的 this 指向，他们两个函数的第一个参数都是一样的，表示要改变指向的那个对象，第二个参数，apply 是数组，而 call 是 arg1, arg2… bind 改变 this 作用域返回一个新的函数，不会立即执行，第二个参数与 call 相同</p><h2 id="js-的各种位置，比如-clientHeight，scrollHeight，offsetHeight，以及-scrollTop，offsetTop，clientTop-的区别？"><a href="#js-的各种位置，比如-clientHeight，scrollHeight，offsetHeight，以及-scrollTop，offsetTop，clientTop-的区别？" class="headerlink" title="js 的各种位置，比如 clientHeight，scrollHeight，offsetHeight，以及 scrollTop，offsetTop，clientTop 的区别？"></a>js 的各种位置，比如 clientHeight，scrollHeight，offsetHeight，以及 scrollTop，offsetTop，clientTop 的区别？</h2><p><strong>clientHeight:</strong> 可视区域的高度，不包含 border 和滚动条</p><p><strong>offsetHeight:</strong> 可视区域的高度，包含 border 和滚动条</p><p><strong>scrollHeight:</strong> 表示了所有区域的高度，包含了因为滚动被隐藏的部分</p><p><strong>clientTop:</strong> 表示边框 border 的厚度，在未指定的情况下一般为 0</p><p><strong>scrollTop:</strong> 滚动后被隐藏的高度，获取对象相对于 offsetParent 属性指定的父坐标距离顶端的高度</p><h2 id="异步加载-js-的方法"><a href="#异步加载-js-的方法" class="headerlink" title="异步加载 js 的方法"></a>异步加载 js 的方法</h2><p><strong>defer：</strong>只支持 IE 如果您的脚本不会改变文档的内容，可将 defer 属性加入到 <code>&lt;script&gt;</code> 标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档地剩余部分而不执行脚本，它将推迟对脚本地解释，知道文档已经显示给用户为止。</p><p>async，HTML5 属性仅使用于外部脚本，并且如果在 IE 中，同时存在 defer 和 async，那么 defer 的优先级比较高，脚本将在页面完成时执行。</p><h2 id="Ajax-解决浏览器缓存问题"><a href="#Ajax-解决浏览器缓存问题" class="headerlink" title="Ajax 解决浏览器缓存问题"></a>Ajax 解决浏览器缓存问题</h2><ul><li>ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”, “0”)</li><li>ajax 发送请求前加上anyAjaxObj.setRequestHeader(“Cache-Control”, “no-cache”)</li><li>在 URL 后面加上随机数：”fresh=” + Math.random()</li><li>在 URL 后面加上时间戳：”nowtime=” + new Date().getTime()</li><li>使用JQuery，$ajaxSetup({cache: false})，所有 ajax 都会执行这条语句不需要保存缓存记录</li></ul><h2 id="js-的节流和防抖"><a href="#js-的节流和防抖" class="headerlink" title="js 的节流和防抖"></a>js 的节流和防抖</h2><ul><li>防抖：在一定时间内，规定事件被触发的次数</li><li>节流：只允许一个函数在 X 毫秒内执行一次</li></ul><h2 id="js-的垃圾回收机制"><a href="#js-的垃圾回收机制" class="headerlink" title="js 的垃圾回收机制"></a>js 的垃圾回收机制</h2><ul><li>必要性：由于字符串、对象和数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</li><li>标记清除：垃圾回收器在运行的时候会给存储在内存中的变量都加上标记，然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。</li><li>引用计数法：声明一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为1；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数减1，当这个值的引用次数为0的时候，说明没有办法访问这个值了，因此就把所占的内存给回收回来，这样垃圾收集器再次运行的时候，就会试放引用次数为0的这些值。会存在内存泄漏。</li></ul><h2 id="eval-是做什么的"><a href="#eval-是做什么的" class="headerlink" title="eval 是做什么的"></a>eval 是做什么的</h2><p>将对应的字符串解析成 js 并执行，应该避免使用 js，因为非常消耗性能（2次，一次解析成 js，一次执行）</p><h2 id="如何理解前端模块化"><a href="#如何理解前端模块化" class="headerlink" title="如何理解前端模块化"></a>如何理解前端模块化</h2><p>前端模块化就是复杂的文件编程一个一个独立的模块，比如 js 文件等等，分成独立的模块有利于重用和维护，这样会引来模块间相互依赖的问题，所以有了commonJs 规范，AMD，CMD 规范等等，以及用于 js 打包的工具 webpack</p><h2 id="说一下Commonjs、AMD-和-CMD"><a href="#说一下Commonjs、AMD-和-CMD" class="headerlink" title="说一下Commonjs、AMD 和 CMD"></a>说一下Commonjs、AMD 和 CMD</h2><p>一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码。</p><p>Commonjs：开始于服务端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules.exports，模块require()引入模块。</p><p>requireJS 实现了 AMD 规范，主要用于解决下述两个问题。</p><ol><li>多文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li><li>加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。</li></ol><p>语法：requireJS 定义了一个函数 define，它是全局变量，用来定义模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块</span></span><br><span class="line">define([<span class="string">&#x27;dependency&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Byron&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">printName</span>: printName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;myModule&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>) </span>&#123;</span><br><span class="line">    my.printName()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>总结 AMD 规范：require（）函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会执行。因为网页在加载 js 的时候会停止渲染，因此我们可以通过异步的方式来加载 js，而如果需要依赖某些，也是异步去依赖，依赖后再执行某些方法。</p><h2 id="对象深度克隆的简单实现"><a href="#对象深度克隆的简单实现" class="headerlink" title="对象深度克隆的简单实现"></a>对象深度克隆的简单实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 newObj 是对象还是数组</span></span><br><span class="line">    <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">var</span> temple = <span class="keyword">typeof</span> obj[item] == <span class="string">&#x27;object&#x27;</span> ? deepClone(obj[item]) : obj[item]</span><br><span class="line">        newObj[item] = temple</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个-once-函数，传入函数参数只执行一次"><a href="#实现一个-once-函数，传入函数参数只执行一次" class="headerlink" title="实现一个 once 函数，传入函数参数只执行一次"></a>实现一个 once 函数，传入函数参数只执行一次</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="literal">true</span>) &#123;</span><br><span class="line">            func.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            tag = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将原生的-ajax-封装成-promise"><a href="#将原生的-ajax-封装成-promise" class="headerlink" title="将原生的 ajax 封装成 promise"></a>将原生的 ajax 封装成 promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myNewAjax = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">&#x27;get&#x27;</span>, url)</span><br><span class="line">        xhr.send(data)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span> &amp;&amp; readyState == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(xhr.reponseText)</span><br><span class="line">                resolve(json)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status != <span class="number">200</span>) &#123;</span><br><span class="line">                reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js-监听对象属性的改变"><a href="#js-监听对象属性的改变" class="headerlink" title="js 监听对象属性的改变"></a>js 监听对象属性的改变</h2><p>假设这里有一个 user 对象</p><ol><li><p>ES5 中使用 Object.defineProperty 来实现已有属性的监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 缺点：如果 id 不在 user 对象中，则不能监听 id 的变化</span></span><br></pre></td></tr></table></figure></li><li><p>ES6 中使用 Proxy 来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 即使有属性在 user 中不存在，通过 user.id 来定义也同样可以监听这个属性的变化</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="如何实现一个私有变量，用-getName-方法可以访问，不能直接访问"><a href="#如何实现一个私有变量，用-getName-方法可以访问，不能直接访问" class="headerlink" title="如何实现一个私有变量，用 getName 方法可以访问，不能直接访问"></a>如何实现一个私有变量，用 getName 方法可以访问，不能直接访问</h2><ol><li><p>通过 defineProperty 来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;fff&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 不可枚举不可配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>通过函数的创建形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">product</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;fff&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> product()</span><br></pre></td></tr></table></figure></li></ol><h2 id="和-、以及Object-is-的区别"><a href="#和-、以及Object-is-的区别" class="headerlink" title="== 和 ===、以及Object.is 的区别"></a>== 和 ===、以及Object.is 的区别</h2><ol><li><p>== 主要存在：强制转换成 number，null == undefine</p><ul><li>“” == 0  // true</li><li>“0” == 0 // true</li><li>“” != “0” // true</li><li>123 == “123” // true</li><li>null == undefined // true</li></ul></li><li><p>Object.is</p><p>主要区别就是 +0 != -0 ，而 NaN == NaN</p><p>(相对于 === 和 == 的改进)</p></li></ol><h2 id="setTimeout、setInterval-和-requestAnimationFrame-之间的区别"><a href="#setTimeout、setInterval-和-requestAnimationFrame-之间的区别" class="headerlink" title="setTimeout、setInterval 和 requestAnimationFrame 之间的区别"></a>setTimeout、setInterval 和 requestAnimationFrame 之间的区别</h2><p>和 setTimeout 和 setInterval 不同，requestAnimationFrame 不需要设置时间间隔。RAF 采用的是系统时间间隔，不会因为前面的任务，影响 RAF，但是如果前面的任务多的话，会响应 setTimeout 和 setInterval 真正运行时的时间间隔。</p><ol><li>requestAnimationFrame 会把每一帧中所有 DOM 操作集中起来，在一次重绘或回流中完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。</li><li>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流。</li><li>requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活的状态下的话，动画会自动暂停，有效节省了 CPU 开销。</li></ol><h2 id="实现一个两列等高布局，讲讲思路"><a href="#实现一个两列等高布局，讲讲思路" class="headerlink" title="实现一个两列等高布局，讲讲思路"></a>实现一个两列等高布局，讲讲思路</h2><p>为了实现两列等高，可以给每列加上 padding-bottom: 9999px; margin-bottom: -9999px; 同时父元素设置 overflow: hidden;</p><h2 id="自己实现一个-bind-函数"><a href="#自己实现一个-bind-函数" class="headerlink" title="自己实现一个 bind 函数"></a>自己实现一个 bind 函数</h2><p>通过 apply 或者 call 方法来实现</p><ol><li><p>初始版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">obj, arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">newArg</span>) </span>&#123;</span><br><span class="line">        arg = arg.concat(<span class="built_in">Array</span>.prototype.slice.call(newArg))</span><br><span class="line">        <span class="keyword">return</span> context.apply(obj, arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>考虑到原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">obj, arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg = <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span></span><br><span class="line">   <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params">newArg</span>) </span>&#123;</span><br><span class="line">        arg = arg.concat(<span class="built_in">Array</span>.prototype.slice.call(newArg))</span><br><span class="line">        <span class="keyword">return</span> context.apply(obj, arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    F.prototype = context.prototype</span><br><span class="line">    bound.prototype = <span class="keyword">new</span> F()</span><br><span class="line">    <span class="keyword">return</span> bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="用-setTimeout-来实现-setInterval"><a href="#用-setTimeout-来实现-setInterval" class="headerlink" title="用 setTimeout 来实现 setInterval"></a>用 setTimeout 来实现 setInterval</h2><p>setInterval 的缺陷：使用 setInterval() 创建的定时器确保了定时器代码规则地插入队列中。这个问题在于：如果定时器代码在代码再次添加到队列之前还没完成执行，结果就会导致定时器代码连续运行好几次。而之间没有间隔。不过幸运的是: javascript 引擎足够聪明，能够避免这个问题。当且仅当没有该定时器的代码实例时，才会将定时器代码添加到队列中。这确保了定时器代码加入队列中最小的时间间隔为指定时间。</p><p>这种重复定时器的规则会有两个问题：</p><ol><li>某些间隔会被跳过</li><li>多个定时器的代码执行时间可能会比预期小</li></ol><p>使用 setTimeout 替代 setInterval</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(say, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(say, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="built_in">arguments</span>.callee, <span class="number">200</span>)</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><h2 id="Function-proto-getPrototypeOf-是什么？"><a href="#Function-proto-getPrototypeOf-是什么？" class="headerlink" title="Function.proto(getPrototypeOf) 是什么？"></a>Function.<em>proto</em>(getPrototypeOf) 是什么？</h2><p>获取一个对象的原型，在 chrome 中可以通过 <em>proto</em> 的形式，或者在 ES6 中可以通过 Object.getPrototype 的形式</p><p>Function. <em>proto</em> == Function.prototype  // true</p><p>Function 的原型也是 Function </p><h2 id="js-判断类型"><a href="#js-判断类型" class="headerlink" title="js 判断类型"></a>js 判断类型</h2><ul><li><p>typeof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;a&#x27;</span> <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span> <span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="comment">// 无法返回内置类型</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">3</span>] <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>instanceof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以返回内置类型</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.toString.call()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回&quot;[Object, 类型]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">999</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&quot;&quot;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()) <span class="comment">// &quot;[object Symbol]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">42n</span>) <span class="comment">// &quot;[object BigInt]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// &quot;[object Date]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pop() <span class="comment">// 尾部删除一个元素，并返回</span></span><br><span class="line">push() <span class="comment">// 尾部添加元素, 返回最终数组长度</span></span><br><span class="line">unshift() <span class="comment">// 头部添加元素，返回最终数组长度</span></span><br><span class="line">shift() <span class="comment">// 头部删除一个元素，并返回</span></span><br><span class="line">slice(start, end) <span class="comment">// 从已有的数组中返回指定的元素</span></span><br><span class="line">splice(index, howmany, item, ..., itemX) <span class="comment">// 改变元数组</span></span><br><span class="line">join() <span class="comment">// 将数组中的元素转换为字符串</span></span><br><span class="line">sort() <span class="comment">// 默认按字母升序</span></span><br><span class="line">reverse() <span class="comment">// 颠倒数组中元素的顺序</span></span><br><span class="line">map() <span class="comment">// 返回新数组，数组中元素为原始元素调用函数处理后的值</span></span><br><span class="line">forEach() <span class="comment">// 修改原数组</span></span><br><span class="line">filter() <span class="comment">// 返回新数组，新数组中元素通过检查指定数组中符合条件的所有元素</span></span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><ol><li><p>indexOf 循环去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.indexOf(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">        array.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ES6 Set去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br></pre></td></tr></table></figure></li><li><p>嵌套 for 循环，利用 splice 去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5最常用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">            arr.splice(j, <span class="number">1</span>)</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="闭包有什么用"><a href="#闭包有什么用" class="headerlink" title="闭包有什么用"></a>闭包有什么用</h2><ol><li><p>什么是闭包</p><p>有权访问另一个函数作用域中的变量的函数</p><p>函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是函数的“堆栈”在函数返回后并不释放，也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当一个函数内定义另一个函数就会产生闭包。</p></li><li><p>为什么要用</p><p>匿名自执行函数：所有的变量，如果不加 var 关键字，则默认添加到全局对象的属性上去。临时变量加入到全局变量有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度。除了每次使用变量都是用 var 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。</p><p>结果缓存：调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找的值即可。闭包正式可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p></li></ol><h2 id="JS-的语言特性"><a href="#JS-的语言特性" class="headerlink" title="JS 的语言特性"></a>JS 的语言特性</h2><ul><li>运行在客户端浏览器上</li><li>不用预编译，直接解析执行代码</li><li>弱类型语言，较为灵活</li><li>与操作系统无关，跨平台的语言</li><li>脚本语言、解释性语言</li></ul><h2 id="如何判断一个数组"><a href="#如何判断一个数组" class="headerlink" title="如何判断一个数组"></a>如何判断一个数组</h2><ul><li>Object.prototype.toString.call()</li><li>instanceof</li></ul><h2 id="typeof-加一个限制条件达到判断条件"><a href="#typeof-加一个限制条件达到判断条件" class="headerlink" title="typeof 加一个限制条件达到判断条件"></a>typeof 加一个限制条件达到判断条件</h2><p>typeof 只能判断 object，可以判断一下是否拥有数组的方法</p><h2 id="JS-实现跨域"><a href="#JS-实现跨域" class="headerlink" title="JS 实现跨域"></a>JS 实现跨域</h2><ul><li>JSONP：通过动态创建 script，再请求一个带参网址实现跨域通信</li><li>document.domain + iframe跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域</li><li>location.hash + iframe 跨域：a 想要与 b 跨域相互通信，通过中间页 c 来实现。三个页面，不同域之间利用 iframe 的location.hash 传值，相同域之间直接 js 访问来通信</li><li>postMessage 跨域：可以跨域操作的 windows 属性之一</li><li>CORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带 cookie 请求，前端后都需要设置</li><li>代理跨域：启一个代理服务器，实现数据的转发</li></ul><h2 id="不同数据类型的值的比较，是怎么转换的，有什么规则"><a href="#不同数据类型的值的比较，是怎么转换的，有什么规则" class="headerlink" title="不同数据类型的值的比较，是怎么转换的，有什么规则"></a>不同数据类型的值的比较，是怎么转换的，有什么规则</h2><ol><li>若 Type(x) 与 Type(y) 相同，则<ul><li>若 Type(x) 为 Undefined，返回 true</li><li>若 Type(x) 为 Null,  返回 true</li><li>若 Type(x) 为 Number，则<ul><li>若 x 为 NaN，返回 false</li><li>若 y 为 NaN，返回 false</li><li>若 x 与 y 为相等数值，返回 true</li><li>若 x 为 +0 且 y = -0，返回 true</li><li>若 x 为 -0 且 y = +0，返回 true</li><li>其他，返回 false</li></ul></li><li>若 Type(x) 为 String，则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true，否则返回 false</li><li>若 Type(x) 为 Boolean，当 x 和 y 同为 true 或者同为 false 时返回 true，否则返回 false。</li></ul></li><li>若 x 为 null 且 y 为 undefined，返回 true</li><li>若 x 为 undefined 且 y 为 null，返回 true</li><li>若 Type(x) 为 Number 且 Type(y) 为 String，返回 x == ToNumber(y) 的结果</li><li>若 Type(x) 为 String 且 Type(y) 为 Number，返回 ToNumber(x) == y</li><li>若 Type(x) 为 Boolean，返回比较 ToNumber(x) == y 的结果</li><li>若 Type(y) 为 Boolean，返回比较 x == ToNumber(y) 的结果</li><li>若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果</li><li>若 Type(x) 为 Object且 Type(y) 为 String 或 Number，返回比较 ToPrimitive(x) == y 的结果</li></ol><h2 id="暂停死区"><a href="#暂停死区" class="headerlink" title="暂停死区"></a>暂停死区</h2><p>在代码块中，使用 let、const 命令声明变量之前，该变量是不可用的。</p><h2 id="说一下什么是-virtual-dom"><a href="#说一下什么是-virtual-dom" class="headerlink" title="说一下什么是 virtual dom"></a>说一下什么是 virtual dom</h2><p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档中。当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两颗树差异。把所记录的差异应用到所创建的真正 DOM 树上，视图就更新了。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。</p><h2 id="webpack-用来干什么的"><a href="#webpack-用来干什么的" class="headerlink" title="webpack 用来干什么的"></a>webpack 用来干什么的</h2><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><h2 id="ant-design-优点和缺点"><a href="#ant-design-优点和缺点" class="headerlink" title="ant-design 优点和缺点"></a>ant-design 优点和缺点</h2><p>优点：组件非常全面，样式效果也都非常不错。</p><p>缺点：框架自定义程度低，默认 UI 风格修改困难。</p><h2 id="vue-的生命周期"><a href="#vue-的生命周期" class="headerlink" title="vue 的生命周期"></a>vue 的生命周期</h2><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 DOM、渲染 -&gt; 更新 -&gt; 渲染、销毁等一系列过程，我们称这是 Vue 的生命周期。</p><ol><li>实例、组件通过 new value() 创建出来之后会初始化事件和生命周期，然后就会执行 beforeCreate 钩子函数，这个时候，数据还没有挂载，无法当问到数据和真实的 DOM</li><li>挂载数据，绑定事件等等，然后执行 created 函数，这个时候已经可以使用到数据，也可以更改数据，在这里更改数据不会触发 updated 函数，渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li><li>开始找实例或者组件对应的模板，编译模板为虚拟 DOM ，放入到 render 函数中准备渲染，然后执行 beforeMount 钩子函数，在这个函数中虚拟 DOM 已经创建完成，马上就要渲染，在这里也可以更改数据，不会触发 updated</li><li>接下来开始 render，渲染真实 DOM，然后执行 mounted 钩子函数，此时，组件已经出现在页面中，数据、真实 DOM 已经处理好了，事件已经挂载好了，可以在这里操作真实 DOM 等事件</li><li>当组件或实例的数据更改之后，会立即执行 beforeUpdate，然后 Vue 的虚拟 DOM 机制会重新构建 DOM ，与上一次的虚拟 DOM 树利用 diff 算法进行对比之后重新渲染</li><li>当更新完成后，执行 updated，数据已经更改完成，DOM 也重新 render 完成，可以操作更新后的虚拟 DOM</li><li>当经过某种途径调用 $destroy 方法后，立即执行 beforeDestroy，一般在这里做一些善后工作，例如清除定时器，清除非指令绑定的事件等等</li><li>组件的数据绑定、监听… 去掉只剩下 DOM 空壳，这个时候，执行 destroyed，在这里做善后工作也可以</li></ol><h2 id="简单介绍一下-symbol"><a href="#简单介绍一下-symbol" class="headerlink" title="简单介绍一下 symbol"></a>简单介绍一下 symbol</h2><p>Symbol 是 ES6 的新增属性，代表用给定名称作为唯一标识，这种类型的值可以这样创建，let id = symbol(“id”)</p><p>Symbol 确保唯一，即使采用相同的名称，也会产生不同的值，我们创建一个字段，仅为知道对应 Symbol 的人能访问，使用 Symbol 很有用，Symbol 并不是 100% 隐藏，有内置方法 Object.getOwnPropertySymbols(obj) 可以获得所有的 symbol</p><h2 id="什么是事件监听"><a href="#什么是事件监听" class="headerlink" title="什么是事件监听"></a>什么是事件监听</h2><p>addEventListener() 方法，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为 element.addEventListener(event, function, useCapture)</p><p>第一个参数是事件的类型(如“click” 或 “mousedown”)</p><p>第二个参数是事件触发后调用的函数</p><p>第三个参数是布尔值用于描述事件是冒泡还是捕获，该参数是可选的</p><p>事件传递有两种方式，冒泡和捕获</p><p>事件传递定义了元素事件触发的顺序，如果你将 p 元素 插入到 div 元素中，用户点击 p 元素，</p><p>在冒泡中，内部元素先被触发，然后再触发外部元素；在捕获中，外部元素先被触发，再触发内部元素</p><h2 id="介绍一下-promise"><a href="#介绍一下-promise" class="headerlink" title="介绍一下 promise"></a>介绍一下 promise</h2><p>Promise 是一个对象，保存着未来将要结束的事件，它有两个特征：</p><ol><li>对象的状态不受外部影响，Promise 对象代表一个异步操作，有三种状态，pending 进行中，fulfilled 已成功，rejected 已失败，只有异步操作的结果，才可以决定当前哪一种状态，任何其他操作都无法改变这个状态，这也是 promise 名字的由来</li><li>一旦状态改变，就不会再变，promise 对象状态改变只有两个可能，从 pending 改到 fulfilled 或者从 pending 改到 rejected，只要这两种情况发生，状态就凝固了，不会再改变，这个时候就称为定型 resolved</li></ol><h2 id="C-，Java，JavaScript-这三种语言的区别"><a href="#C-，Java，JavaScript-这三种语言的区别" class="headerlink" title="C++，Java，JavaScript 这三种语言的区别"></a>C++，Java，JavaScript 这三种语言的区别</h2><p>从静态类型还是动态类型来看：</p><p>静态类型，编译的时候就能够知道每个变量的类型，编译的时候也需要给定类型，如 Java 中的整型 int，浮点型 float 等。C++、Java 都属于静态类型语言。</p><p>动态类型，运行的时候才知道每个变量的类型，编程的时候无需显示指定类型，如 JavaScript 中的var、PHP 中的$。JavaScirpt、Ruby 和 Python 都属于动态类型语言。</p><p>从编译型还是解释型来看：</p><p>编译型语言，像 C、C++，需要编译器编译成本地可执行程序后才可运行，由开发人员编写完成后手动实施。</p><p>解释性语言，像 JavaScript 、Python ，开发语言写好后直接将代码交给用户，用户使用脚本解释器将脚本文件解释执行。对于脚本语言，没有开发人员的编译过程。</p><h2 id="JS-原型链，原型链的顶端是什么？Object-的原型是什么？Object-的原型的原型是什么？"><a href="#JS-原型链，原型链的顶端是什么？Object-的原型是什么？Object-的原型的原型是什么？" class="headerlink" title="JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？"></a>JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？</h2><p><a href="https://image-static.segmentfault.com/842/884/84288451-5ab1c39fe94bf_fix732">84288451-5ab1c39fe94bf_fix732 (732×442) (segmentfault.com)</a></p><p>原型链的顶端：Object.prototype，其 <em>proto</em> = null</p><p>Object 的原型：Function.prototype</p><p>Object 的原型的原型：Object.prototype</p><h2 id="什么是-js-的闭包？有什么作用，用闭包写个单例模式"><a href="#什么是-js-的闭包？有什么作用，用闭包写个单例模式" class="headerlink" title="什么是 js 的闭包？有什么作用，用闭包写个单例模式"></a>什么是 js 的闭包？有什么作用，用闭包写个单例模式</h2><p>闭包 = 函数 + 函数内部能够访问到的自由变量</p><p>作用：</p><ol><li>模仿块级作用域</li><li>保存外部函数的变量</li><li>封装私有变量</li></ol><p>单例模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">var</span> createSingleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="keyword">if</span> (instace) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.getName()</span><br><span class="line">        <span class="keyword">return</span> instance = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    createSingleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createSingleton</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="事件委托以及冒泡原理"><a href="#事件委托以及冒泡原理" class="headerlink" title="事件委托以及冒泡原理"></a>事件委托以及冒泡原理</h2><p>事件委托是利用冒泡阶段的运行机制来实现的，就是把一个元素响应事件的函数委托到另一个元素，一般把一组元素的事件委托到他的父元素上，委托的优点是减少内存消耗，节约效率。</p><p>事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如 onclick 事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，知道document/window，冒泡过程结束。</p><h2 id="JS-中的-string-的-startsWith-和-indexof-两种方法的区别"><a href="#JS-中的-string-的-startsWith-和-indexof-两种方法的区别" class="headerlink" title="JS 中的 string 的 startsWith 和 indexof 两种方法的区别"></a>JS 中的 string 的 startsWith 和 indexof 两种方法的区别</h2><p>JS 中的 startsWith 函数，其参数有 2个，str，搜索的字符串，position，可选，从哪个位置开始搜索，如果以 position 开始的字符串以搜索字符串开头，则返回 true，否则返回 false。</p><p>indexOf 函数，可返回某个字符串在字符串中首次出现的位置。</p><h2 id="JS-字符串转数字的方法"><a href="#JS-字符串转数字的方法" class="headerlink" title="JS 字符串转数字的方法"></a>JS 字符串转数字的方法</h2><ol><li>通过函数 parseInt()，可解析一个字符串，并返回一个整数，语法为 parseInt(str, radix)，string：被解析的字符串；radix：表示要解析的数字的基数，默认是十进制，如果 radix &lt; 2 或 &gt; 36，则返回 NaN</li><li>Number() 转换函数，只能基于十进制进行转换，并且字符串中不能出现非数字的字符，否则返回 NaN</li><li>parseFloat()</li></ol><h2 id="let-const-var-的区别，什么是块作用域，如何用-ES5-的方法实现块作用域（立即执行函数），ES6呢"><a href="#let-const-var-的区别，什么是块作用域，如何用-ES5-的方法实现块作用域（立即执行函数），ES6呢" class="headerlink" title="let const var 的区别，什么是块作用域，如何用 ES5 的方法实现块作用域（立即执行函数），ES6呢"></a>let const var 的区别，什么是块作用域，如何用 ES5 的方法实现块作用域（立即执行函数），ES6呢</h2><p>var 声明的变量是全局或者整个函数块的，而 let、const 声明的变量是块级的变量。 var 声明的变量存在变量提升，let、const 不存在，let 声明的变量允许重新赋值，const 不允许。</p><ul><li>块级作用域：任何一对花括号的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</li><li>ES5 中实现块级作用域：立即执行函数</li></ul><h2 id="ES6-箭头函数的特性"><a href="#ES6-箭头函数的特性" class="headerlink" title="ES6 箭头函数的特性"></a>ES6 箭头函数的特性</h2><ul><li>箭头函数没有 this，所以需要通过查找作用域来确定 this 的值，这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this</li><li>箭头函数没有自己的 arguments 对象，但是可以访问外围函数的 arguments 对象</li><li>不能通过 new 关键字调用，同样没有 new.target 值和原型</li></ul><h2 id="JS-的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN-是什么的缩写，JS-的作用域类型，undefined-null-返回的结果是什么，undefined-和-null-的区别在哪，写一个函数判断变量类型"><a href="#JS-的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN-是什么的缩写，JS-的作用域类型，undefined-null-返回的结果是什么，undefined-和-null-的区别在哪，写一个函数判断变量类型" class="headerlink" title="JS 的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN 是什么的缩写，JS 的作用域类型，undefined == null 返回的结果是什么，undefined 和 null 的区别在哪，写一个函数判断变量类型"></a>JS 的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN 是什么的缩写，JS 的作用域类型，undefined == null 返回的结果是什么，undefined 和 null 的区别在哪，写一个函数判断变量类型</h2><ul><li>基本数据类型：Number，String，Boolean，Null，Undefined，Symbol</li><li>区别：<ul><li>基本数据类型的值是不可变的，改变的只是指针的指向，该变量是不变的，但是引用类型是可以改变的</li><li>基本数据类型不可以添加属性方法，但是引用类型可以</li><li>基本数据类型是存放在栈区的，引用数据类型同时存放在栈区和堆</li><li>基本数据类型的赋值是简单赋值，引用类型的赋值是对象引用</li></ul></li></ul><p>undefined == null // true</p><p>undefined === null // false</p><h2 id="setTimeout-fn-100-100-毫秒是如何权衡的"><a href="#setTimeout-fn-100-100-毫秒是如何权衡的" class="headerlink" title="setTimeout(fn, 100); 100 毫秒是如何权衡的"></a>setTimeout(fn, 100); 100 毫秒是如何权衡的</h2><p>setTimeout() 函数只是将事件插入了任务列表，必须等到当前代码执行完，主线程才会执行它指定的回调函数，有可能要等很久，所以没办法保证回调函数一定会在 setTimeout 指定的时间内执行，100 毫秒是插入队列的时间 + 等待的时间</p><h2 id="获得对象上的属性的方法"><a href="#获得对象上的属性的方法" class="headerlink" title="获得对象上的属性的方法"></a>获得对象上的属性的方法</h2><ul><li>for (let i in obj) 该方法依次访问一个对象及其原型链中所有可枚举的类型</li><li>object.keys 返回一个数组，包括所有可枚举的属性名称</li><li>object.getOwnPropertyNames 返回一个数组，包含不可枚举的属性</li></ul><h2 id="简单讲一讲-ES6-的一些新特性"><a href="#简单讲一讲-ES6-的一些新特性" class="headerlink" title="简单讲一讲 ES6 的一些新特性"></a>简单讲一讲 ES6 的一些新特性</h2><ul><li>增加 let、 const 声明变量</li><li>引入新的数据类型 symbol</li><li>引入 promise 和 generator</li><li>引入了实现 Class 和模块</li></ul><p>重要特性</p><ul><li>块级作用域，不再需要立即执行函数，循环体中的闭包不再有问题</li><li>rest 参数，用于获取函数的多余参数，不再需要使用 arguments 对象了</li><li>promise，一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大</li><li>模块化，其模块功能只要有两个命令构成，export 和 import，export 命令用于规定模块的对外接口，import 命令输入其他模块提供的功能</li></ul><h2 id="call-和-apply-是用来做什么的的"><a href="#call-和-apply-是用来做什么的的" class="headerlink" title="call 和 apply 是用来做什么的的"></a>call 和 apply 是用来做什么的的</h2><ol><li>改变 this 指向</li><li>借用其他对象的方法</li><li>调用函数，因为 apply 和 call 方法会使函数立即执行</li></ol><h2 id="js-加载过程中阻塞，解决方法"><a href="#js-加载过程中阻塞，解决方法" class="headerlink" title="js 加载过程中阻塞，解决方法"></a>js 加载过程中阻塞，解决方法</h2><p>指定 script 标签的 async 属性。如果 async = “async” ，脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本会执行）</p><p>如果不适用 async 且 defer = “defer” ，脚本将在页面完成解析时执行</p><h2 id="new-操作符原理"><a href="#new-操作符原理" class="headerlink" title="new 操作符原理"></a>new 操作符原理</h2><ol><li>创建一个类的实例：创建一个空对象 obj，然后把这个空对象的 <em>proto</em> 设置为构造函数的 prototype</li><li>初始化实例：构造函数被传入参数并调用，关键字 this 被设定指向该实例 obj</li><li>返回 obj</li></ol><h2 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h2><p>在程序中设置两个线程：一个负责程序本身的运行，称为“主线程”；另一个负责主线程和其他进程（主要是各种 I/O 操作）的通信，被称为“Event Loop线程”</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS知识合集</title>
      <link href="/2021/08/18/CSS%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/"/>
      <url>/2021/08/18/CSS%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="解释一下CSS的盒子模型"><a href="#解释一下CSS的盒子模型" class="headerlink" title="解释一下CSS的盒子模型"></a>解释一下CSS的盒子模型</h2><ul><li><strong>标准的css盒模型：</strong>width = content</li><li><strong>IE盒模型：</strong>width = content + padding-left + padding-right + border-left + border-right</li></ul><h2 id="请你说说CSS选择器有哪些，并举几个例子说明其用法？"><a href="#请你说说CSS选择器有哪些，并举几个例子说明其用法？" class="headerlink" title="请你说说CSS选择器有哪些，并举几个例子说明其用法？"></a>请你说说CSS选择器有哪些，并举几个例子说明其用法？</h2><p><strong>类型：</strong></p><ul><li><strong>基础选择器：</strong>通用元素选择器*，标签选择器，class选择器，id选择器</li><li><strong>组合选择器：</strong>多元素选择器（A, B），后代元素选择器（A B），子元素选择器（A&gt;B），相邻元素选择器（A + B）</li><li><strong>属性选择器：</strong>具有att属性的元素（E[att]），具有att属性等于“val”的元素（E[att=val]），att属性包含单词 “val” 的所有元素（E[att~=val]），选择 att 属性值以 “en” 开头的所有元素（E[att|=val]）</li><li><strong>伪类选择器：</strong>E:first-child，E:link，E:visited，E:active，E:hover，E:focus，E:lang(c)</li><li><strong>伪元素选择器：</strong>E:first-line，E:first-letter，E:before，E:after</li></ul><h2 id="请你说说CSS有什么特殊性"><a href="#请你说说CSS有什么特殊性" class="headerlink" title="请你说说CSS有什么特殊性"></a>请你说说CSS有什么特殊性</h2><p><strong>优先级：</strong></p><ul><li>同类型，同级别的样式后者大于前者</li><li>ID &gt; 类样式 &gt; 标签 &gt; *</li><li>内联 &gt; ID选择器 &gt; 伪类 &gt; 属性选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通用选择器 &gt; 继承的样式</li><li>内联样式 &gt; 内部样式 &gt; 外联样式表</li><li>!important权重最高</li></ul><p><strong>计算特殊性值</strong>：CSS样式选择器分为4各等级: a、b、c、d</p><ul><li>如果样式是行内样式，a = 1, 0, 0, 0</li><li>ID选择器，b = 0, 1, 0, 0</li><li>属性选择器，伪类选择器，class类选择器，c = 0, 0, 1, 0</li><li>标签、伪元素选择器，d = 0, 0, 0, 1</li></ul><h2 id="动态改变层中内容可以使用的方法？"><a href="#动态改变层中内容可以使用的方法？" class="headerlink" title="动态改变层中内容可以使用的方法？"></a>动态改变层中内容可以使用的方法？</h2><ul><li>innerHTML</li><li>innerText</li></ul><h2 id="常见浏览器兼容性问题与解决方案？"><a href="#常见浏览器兼容性问题与解决方案？" class="headerlink" title="常见浏览器兼容性问题与解决方案？"></a>常见浏览器兼容性问题与解决方案？</h2><ol><li><p>不同浏览器的默认标签默认margin和padding不同</p><p><strong>解决方案：CSS里 * {margin: 0; padding: 0;}</strong></p></li><li><p>块属性标签float后，又有横行的margin情况下，在IE6显示的margin比设置的大</p><p><strong>解决方案：在float的标签样式控制中加入display: inline; 将其转化为行内属性</strong></p></li><li><p>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置的高度</p><p><strong>解决方案：给超出高度的标签设置overflow: hidden; 或者设置行高小于你设置的高度</strong></p></li><li><p>行内属性标签，设置 display:block 后采用 float 布局，又<br>有横行的 margin 的情况，IE6间距bug</p><p><strong>解决方案：在display: block; 后面加入display: inline; display: table;</strong></p></li><li><p>图片默认有间距（使用问题一的解决方案无效）</p><p><strong>解决方案：使用float属性为img布局</strong></p></li><li><p>标签最低高度设置min-height不兼容</p><p><strong>解决方案：如果我们要设置一个标签的最小高度 200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}</strong></p></li><li><p>透明度的兼容CSS设置</p><p><strong>解决方案：ie中使用filter: alpha(opacity=0);（兼容IE8及以下的IE浏览器） firefox中使用opacity: 0; 兼容时都写上即可</strong></p></li></ol><h2 id="列出display的值并说明他们的作用？"><a href="#列出display的值并说明他们的作用？" class="headerlink" title="列出display的值并说明他们的作用？"></a>列出display的值并说明他们的作用？</h2><ul><li><strong>默认值：</strong>inline</li><li><strong>none：</strong>隐藏对象。与visibility的属性hidden值不同，其不为被隐藏的对象保留物理空间</li><li><strong>inline：</strong>指定对象为内联元素</li><li><strong>inline-block：</strong>指定元素为内联块元素</li><li><strong>block：</strong>指定元素为块元素</li><li><strong>list-item：</strong>指定对象为列表项目</li><li><strong>table：</strong>指定对象为块元素的表格，类同于标签<code>&lt;table&gt;</code></li><li><strong>inline-table：</strong>指定对象作为内联元素级的表格，类同于html标签<code>&lt;table&gt;</code></li><li><strong>table-caption：</strong>指定对象作为表格标题，类同于html标签<code>&lt;caption&gt;</code></li><li><strong>table-cell：</strong>指定对象作为表格单元格，类同于html标签<code>&lt;td&gt;</code></li><li><strong>table-row：</strong>指定对象作为表格行，类同于html标签<code>&lt;tr&gt;</code></li><li><strong>table-row-group：</strong>指定对象作为表格行组，类同于html标签<code>&lt;tbody&gt;</code></li><li><strong>table-header-group：</strong>指定对象作为表格标题组，类同于html标签<code>&lt;thead&gt;</code></li><li><strong>table-column：</strong>指定对象作为表格列，类同于html标签<code>&lt;col&gt;</code></li><li><strong>table-column-group：</strong>指定对象作为表格列组显示，类同于html标签<code>&lt;colgroup&gt;</code></li><li><strong>table-header-group：</strong>指定对象作为表格标题组，类同于html标签<code>&lt;thead&gt;</code></li><li><strong>table-footer-group：</strong>指定对象作为表格脚注组，类同于html标签<code>&lt;tfoot&gt;</code></li><li><strong>run-in：</strong>根据上下文决定对象是内联对象还是块级对象（CSS3）</li><li><strong>box：</strong>将对象作为弹性伸缩盒显示（CSS3）</li><li><strong>inline-box：</strong>将对象作为内联块级弹性伸缩盒显示（CSS3）</li><li><strong>flexbox：</strong>将对象作为弹性伸缩盒显示（CSS3）</li><li><strong>inline-flexbox：</strong>将对象作为内联块级弹性伸缩盒显示（CSS3）</li><li><strong>flex：</strong>将对象作为弹性伸缩盒显示（CSS3）</li><li><strong>inline-flex：</strong>将对象作为内联块级弹性伸缩盒显示（CSS3）</li></ul><h2 id="如何居中div，如何居中一个浮动元素？"><a href="#如何居中div，如何居中一个浮动元素？" class="headerlink" title="如何居中div，如何居中一个浮动元素？"></a>如何居中div，如何居中一个浮动元素？</h2><ul><li>非浮动元素：设置margin：0 auto，定位，父级元素text-align: center;</li><li>浮动元素<ul><li>设置当前的宽度，然后设置margin-left：50%; position: relative; left: -250px;其中的left是宽度的一半</li><li>父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对左移动-50%</li><li>position定位</li></ul></li></ul><h2 id="CSS中link和-import的区别是？"><a href="#CSS中link和-import的区别是？" class="headerlink" title="CSS中link和@import的区别是？"></a>CSS中link和@import的区别是？</h2><ul><li>link属于html标签，而@import是CSS提供的</li><li>页面被加载时，link同时加载，而@import引用的css等到页面加载完再加载</li><li>@import只在IE5以上才能识别，link是html标签，无兼容问题</li><li>link方式的样式权重样式@import的权重</li></ul><h2 id="请列举几种清除浮动的方法？"><a href="#请列举几种清除浮动的方法？" class="headerlink" title="请列举几种清除浮动的方法？"></a>请列举几种清除浮动的方法？</h2><ul><li>父级div设置高度</li><li>结尾处加上div标签，设置clear：both</li><li>父级div定义伪类：after和zoom</li><li>父级div定义overflow：hidden</li></ul><h2 id="block，inline和inline-block细节对比？"><a href="#block，inline和inline-block细节对比？" class="headerlink" title="block，inline和inline-block细节对比？"></a>block，inline和inline-block细节对比？</h2><ul><li><p>display：block</p><ul><li>block元素会独占一行。默认情况下，block元素宽度自动填满其父元素宽度</li><li>block元素可以设置width，height属性</li></ul></li><li><p>display：inline</p><ul><li>inline元素不会独占一行，多个响铃的行内元素会排列在同一行里，直到一行排列不下</li><li>inline元素的margin和padding属性，水平方向的padding和margin会产生边距效果；但竖直方向的padding和margin无效</li><li>inline元素设置width，height无效</li></ul></li><li><p>display：inline-block</p><ul><li>看做是排列在一行的block元素</li></ul></li></ul><h2 id="什么是优雅降级和渐进增强？"><a href="#什么是优雅降级和渐进增强？" class="headerlink" title="什么是优雅降级和渐进增强？"></a>什么是优雅降级和渐进增强？</h2><ul><li><strong>优雅降级：</strong>web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的和模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形势降级体验却不至于完全失效</li><li><strong>渐进增强：</strong>从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持地功能，向页面增加无害于基础浏览器地额外样式和功能的。当浏览器支持时，它们会自动呈现出来并发挥作用。</li></ul><h2 id="说说浮动元素会引起的问题和你的解决办法"><a href="#说说浮动元素会引起的问题和你的解决办法" class="headerlink" title="说说浮动元素会引起的问题和你的解决办法"></a>说说浮动元素会引起的问题和你的解决办法</h2><p><strong>问题：</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面的显示结构</li></ul><p><strong>解决方法：</strong></p><ul><li>对于问题（2）（3）使用css设置clear:both即可</li><li>对于问题（1）给父元素添加.clearfix:after{content:””;display:block;height:0;clear:both;}也可以使用overflow: hidden;</li></ul><h2 id="你有哪些性能优化的方法？"><a href="#你有哪些性能优化的方法？" class="headerlink" title="你有哪些性能优化的方法？"></a>你有哪些性能优化的方法？</h2><ol><li>减少HTTP请求次数</li><li>使用CDN</li><li>避免空的src和href</li><li>为文件头指定Expires</li><li>使用gzip压缩内容</li><li>把CSS放在顶部</li><li>把JS放在底部</li><li>避免使用CSS表达式</li><li>避免跳转</li><li>可缓存的AJAX</li><li>使用GET来完成AJAX请求</li></ol><h2 id="为什么要初始化CSS样式"><a href="#为什么要初始化CSS样式" class="headerlink" title="为什么要初始化CSS样式"></a>为什么要初始化CSS样式</h2><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没有对CSS初始化往往会出现浏览器之间的页面显示差异</p><h2 id="解释下浮动和它的工作原理？"><a href="#解释下浮动和它的工作原理？" class="headerlink" title="解释下浮动和它的工作原理？"></a>解释下浮动和它的工作原理？</h2><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留</p><h2 id="CSS样式表根据所在网页的位置，可分为哪几种样式表？"><a href="#CSS样式表根据所在网页的位置，可分为哪几种样式表？" class="headerlink" title="CSS样式表根据所在网页的位置，可分为哪几种样式表？"></a>CSS样式表根据所在网页的位置，可分为哪几种样式表？</h2><ul><li>行内样式表</li><li>内嵌样式表</li><li>外部样式表</li></ul><h2 id="谈谈你对CSS中刻度的认识？"><a href="#谈谈你对CSS中刻度的认识？" class="headerlink" title="谈谈你对CSS中刻度的认识？"></a>谈谈你对CSS中刻度的认识？</h2><p>在CSS中刻度是用于设置元素尺寸的单位</p><ul><li>特殊值0可以省略单位。例如：margin: 0px 可以写成margin: 0</li><li>一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持长度值，那应该变换到能够被支持的最近的一个长度值</li><li>相对长度单位：em，ex，ch，rem，vw，vh，vmax，vmin</li><li>绝对长度单位：cm，mm，q，in，pt，pc，px</li><li>文本相对长度单位：em，rem（CSS新增的，相对于根元素font-size计算值的倍数）</li></ul><h2 id="请你说说em和rem的区别？"><a href="#请你说说em和rem的区别？" class="headerlink" title="请你说说em和rem的区别？"></a>请你说说em和rem的区别？</h2><p>区别在于em计算的规则依赖于父元素，rem计算的规则依赖根元素</p><ul><li>rem：CSS3新增的一个相对单位，相对于根元素font-szie计算值的倍数</li><li>em：文本相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被认为设置，则相对于浏览器的默认字体尺寸。</li></ul><h2 id="请你说说box-sizing属性的用法？"><a href="#请你说说box-sizing属性的用法？" class="headerlink" title="请你说说box-sizing属性的用法？"></a>请你说说box-sizing属性的用法？</h2><ul><li><strong>box-sizing: content-box</strong>   padding和border不被包含在定义的width和height内。对象的实际高度等于设置的width和border、padding之和，width = width + border + padding，此属性表现为标准模式下的盒模型</li><li><strong>box-sizing: border-box</strong>  padding和border被包含在定义的width和height之内。对象的实际宽度等于设置的width值，即使定义有border和padding也不会高边对象的实际宽度，即此属性表现为怪异模式下的盒模型。</li></ul><h2 id="说说你对边距折叠的理解？"><a href="#说说你对边距折叠的理解？" class="headerlink" title="说说你对边距折叠的理解？"></a>说说你对边距折叠的理解？</h2><ul><li><strong>外边距折叠：</strong>相邻的两个或多个外边距在垂直方向会合并成一个外边距</li><li><strong>垂直方向外边距合并计算</strong><ul><li>参加的折叠 margin 都是正值：取其中 margin 较大的值为最终 margin 值</li><li>参与折叠的 margin 都是负值：取的是其中绝对值较大的，然后从0开始，负向位移</li><li>参与折叠的 margin 中有正值和负值：先取出负 margin 中绝对值最大的，然后和正margin值中最大的 margin 相加</li></ul></li></ul><h2 id="说说隐藏元素的方式有哪些？"><a href="#说说隐藏元素的方式有哪些？" class="headerlink" title="说说隐藏元素的方式有哪些？"></a>说说隐藏元素的方式有哪些？</h2><ul><li>使用CSS的 display: none; 不会占用原来的位置</li><li>使用CSS的 visibility: hidden; 会占用原来的位置</li><li>使用HTML5中的新增属性 hidden: “hidden”，不会占用原来的位置</li></ul><h2 id="谈谈你对BFC和IFC的理解？"><a href="#谈谈你对BFC和IFC的理解？" class="headerlink" title="谈谈你对BFC和IFC的理解？"></a>谈谈你对BFC和IFC的理解？</h2><h3 id="1-什么是BFC和IFC"><a href="#1-什么是BFC和IFC" class="headerlink" title="1. 什么是BFC和IFC"></a>1. 什么是BFC和IFC</h3><ul><li>BFC即“块级格式化上下文”，IFC即行内格式化上下文。可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用</li><li>BFC决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。浮动元素会形成BFC，浮动元素内部子元素主要受浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC是一个作用范围。</li></ul><h3 id="2-如何产生BFC"><a href="#2-如何产生BFC" class="headerlink" title="2. 如何产生BFC"></a>2. 如何产生BFC</h3><ul><li>float值不为none</li><li>overflow的值不为visible</li><li>display的值为table-cell，table-caption，inline-box中其中一个</li><li>position的值不为relative和static</li></ul><h3 id="3-BFC的作用与特点"><a href="#3-BFC的作用与特点" class="headerlink" title="3. BFC的作用与特点"></a>3. BFC的作用与特点</h3><p>不和浮动元素重叠，清除外部浮动，阻止浮动元素覆盖。</p><p>如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个重叠的现象。</p><h2 id="如何解决多个元素重叠问题"><a href="#如何解决多个元素重叠问题" class="headerlink" title="如何解决多个元素重叠问题"></a>如何解决多个元素重叠问题</h2><p>使用z-index属性可以设置元素的层叠顺序</p><h2 id="页面布局的方法有哪些？"><a href="#页面布局的方法有哪些？" class="headerlink" title="页面布局的方法有哪些？"></a>页面布局的方法有哪些？</h2><ul><li><p>双飞翼（圣杯）布局</p><ul><li>三列布局，中间宽度自适应，两边定宽</li><li>中间栏要在浏览器中优先展示渲染</li><li>允许只用一个额外的DIV标签</li><li>要求用最简单的CSS，最少的HACK语句</li></ul></li><li><p>多栏布局</p><ul><li>栏栅格布局</li><li>多列布局</li></ul></li><li><p>弹性布局</p><p>flexbox布局</p></li><li><p>流式布局（Fluid）</p></li><li><p>瀑布流布局</p></li><li><p>响应式布局</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML知识合集</title>
      <link href="/2021/08/15/HTML%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/"/>
      <url>/2021/08/15/HTML%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器页面由哪三层构成，分别是什么，作用是什么"><a href="#浏览器页面由哪三层构成，分别是什么，作用是什么" class="headerlink" title="浏览器页面由哪三层构成，分别是什么，作用是什么"></a>浏览器页面由哪三层构成，分别是什么，作用是什么</h2><p><strong>构成：</strong> 结构层、表示层、行为层</p><p><strong>分别是：</strong>HTML、CSS、JavaScript</p><p><strong>作用：</strong> HTML实现页面结构、CSS完成页面的表现与风格、JavaScript实现客户端的一些功能和业务</p><p>★ 网页的表示层和行为层总是存在的，即使我们未给出任何具体的指令。此时，Web浏览器把它默认样式和默认事件处理函数施加在网页的结构上。例如，浏览器会在呈现“文本段”元素时留出页边距，有些浏览器会在用户把鼠标悬停在某个元素的上方时弹出一个显示该元素的title属性值的提示框，等等。</p><h2 id="HTML5的优点与缺点"><a href="#HTML5的优点与缺点" class="headerlink" title="HTML5的优点与缺点"></a>HTML5的优点与缺点</h2><h3 id="一、优点"><a href="#一、优点" class="headerlink" title="一、优点"></a>一、优点</h3><ul><li>提高可用性和改进用户的友好体验</li><li>加入几个新标签，有助于开发人员定义重要内容</li><li>可给站点带来更多多媒体元素（视频和音频）</li><li>可很好的替代Flash和Sliverlight（跨浏览器、跨平台插件，为网络带来下一代基于.NET媒体体验）</li><li>涉及网站抓取和索引时，SEO很友好</li><li>可大量应用于移动应用程序和游戏</li><li>可移植性好</li></ul><h3 id="二、缺点"><a href="#二、缺点" class="headerlink" title="二、缺点"></a>二、缺点</h3><ul><li>安全：web storage、web socket 这样的 功能很容易被黑客利用，来盗取用户的信息和资料。</li><li>完善性：许多特性各浏览器支持程度也不一样</li><li>性能：某些平台下的引擎问题导致HTML5性能低下</li><li>浏览器兼容性：IE9以下浏览器几乎全军覆没</li></ul><h2 id="Doctype作用？严格模式和混杂模式如何区分？它们有何差异？"><a href="#Doctype作用？严格模式和混杂模式如何区分？它们有何差异？" class="headerlink" title="Doctype作用？严格模式和混杂模式如何区分？它们有何差异？"></a>Doctype作用？严格模式和混杂模式如何区分？它们有何差异？</h2><h3 id="一、Doctype的作用是什么？"><a href="#一、Doctype的作用是什么？" class="headerlink" title="一、Doctype的作用是什么？"></a>一、Doctype的作用是什么？</h3><p>‘&lt;!DOCTYPE&gt;声明叫做文件类型定义（DTD），<br>声明的作用是为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪些规范来解析文档。&lt;!DOCTYPE&gt;声明必须在HTML文档的第一行，这并不是一个HTML标签。</p><h3 id="二、严格模式与混杂模式如何区分？它们有何意义？"><a href="#二、严格模式与混杂模式如何区分？它们有何意义？" class="headerlink" title="二、严格模式与混杂模式如何区分？它们有何意义？"></a>二、严格模式与混杂模式如何区分？它们有何意义？</h3><p><strong>严格模式：</strong> 又称标准模式，是指浏览器按照W3C标准解析代码</p><p><strong>混杂模式：</strong> 又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码</p><p><strong>如何区分：</strong> 浏览器解析时到底使用严格模式还是混杂模式，与网页中的DTD直接相关。若文档包含严格的DTD或者包含有URI的过渡DTD，以严格模式呈现；若由没有URI的过渡DTD或DOCTYPE不存在/格式不正确，以混杂模式呈现。</p><p><strong>意义：</strong> 两种模式存在的意义与来源密切相关，只存在严格模式，许多旧网站会受到影响，只存在混杂模式，就会回到当时浏览器大混战时的混乱，每个浏览器都有自己的解析模式。</p><p>★ HTML5没有DTD，因此没有严格模式与混杂模式的区别</p><h3 id="三、差异"><a href="#三、差异" class="headerlink" title="三、差异"></a>三、差异</h3><ul><li><strong>盒模型高度：</strong>严格模式指的是元素的内容和高度，混杂模式还包含padding和border</li><li><strong>设置行内元素的高度：</strong>严格模式下，给span等行内元素设置宽高都不会生效，混杂模式下会生效</li><li><strong>设置百分比的高度：</strong>严格模式下，元素高度由其包含的内容来决定，如果父元素没有高度，子元素设置百分比高度无效</li><li><strong>用margin: 0 auto 设置水平居中：</strong>严格模式下，可以使元素水平居中，混杂模式下失效，解决方法用text-align属性</li><li><strong>混杂模式下</strong>设置图片的padding失效，table中的字体属性不能继承上层的设置，white-space: pre （处理元素内的空白）会失效</li></ul><h3 id="四、常用的具体声明"><a href="#四、常用的具体声明" class="headerlink" title="四、常用的具体声明"></a>四、常用的具体声明</h3><ul><li><strong>HTML5</strong>：<ol><li> <!DOCTYPE html></li></ol></li><li><strong>HTML 4.01:</strong> 严格模式包含所有HTML元素和属性，但不包括展示性的和弃用的元素（如font），不允许框架集（Framesets）;过渡模式包含所有HTML元素和属性，包含展示性的和弃用的元素（如font），不允许框架集（Framesets）；框架模式等同于过渡模式，但允许框架集内容。<ol><li> HTML 4.01 Strict ：<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> </li><li> HTML 4.01 Transitional ：<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  "http://www.w3.org/TR/html4/loose.dtd"> </li><li> HTML 4.01 Frameset ：<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN"  "http://www.w3.org/TR/html4/frameset.dtd"></li></ol></li><li><strong>XHTML 1.0（四种）：</strong>前三种模式同上，XHML 必须以格式正确的 XML 来编写标记。<ol><li>  XHTML 1.0 Strict ：<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> </li><li> XHTML 1.0 Transitional ：<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" " http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> </li><li> XHTML 1.0 Frameset： <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"> </li><li> XHTML 1.1 该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型。<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">  </li></ol></li></ul><h2 id="HTML5有哪些新特性、移除了哪些元素？"><a href="#HTML5有哪些新特性、移除了哪些元素？" class="headerlink" title="HTML5有哪些新特性、移除了哪些元素？"></a>HTML5有哪些新特性、移除了哪些元素？</h2><h3 id="一、新特性"><a href="#一、新特性" class="headerlink" title="一、新特性"></a>一、新特性</h3><ul><li><strong>语义化标签：</strong><header></header><nav></nav>等</li><li><strong>绘画canvas</strong></li><li><strong>SVG绘图</strong></li><li><strong>视频和音频</strong>，用于媒介的video和audio元素</li><li><strong>input增强型表单控件：</strong>calendar，date，time，email，url，search</li><li><strong>本地离线存储：</strong>localStorage长期存储数据，浏览器关闭后数据不丢失；sessionStorage的数据在浏览器关闭后自动删除</li><li><strong>新的技术：</strong>WebWorker，WebSocket，Geolocation<ol><li> <a href="https://www.cnblogs.com/ccnNL/p/9911248.html">WebWork</a>：工作线程，允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM</li><li> <a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket</a>：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</li></ol><ul><li>建立在TCP协议之上，服务器端实现比较容易</li><li>与HTTP协议有良好的兼容性。默认端口也是80和443</li><li>没有<a href="https://baike.baidu.com/item/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/3927875?fr=aladdin">同源</a>限制，客户端可以与任意服务器通信</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是URL</li></ul><ol start="3"><li><a href="https://www.runoob.com/html/html5-geolocation.html">Geolocation</a>：地理定位，用于定位用户的位置</li></ol></li></ul><h3 id="二、移除的元素"><a href="#二、移除的元素" class="headerlink" title="二、移除的元素"></a>二、移除的元素</h3><ul><li><strong>纯表现的元素：</strong>basefont， big， center， font， s， strike， tt， u</li><li><strong>对可用性产生负面影响的元素：</strong> frame， frameset， noframes</li></ul><h2 id="你做的网页在哪些浏览器测试过，这些浏览器的内核是什么？"><a href="#你做的网页在哪些浏览器测试过，这些浏览器的内核是什么？" class="headerlink" title="你做的网页在哪些浏览器测试过，这些浏览器的内核是什么？"></a>你做的网页在哪些浏览器测试过，这些浏览器的内核是什么？</h2><ul><li><strong>IE：</strong>trident（IE6~IE11）</li><li><strong>Chrome：</strong>Blink（基于webkit，Google和Opera Software共同开发）</li><li><strong>FireFox：</strong>gecko</li><li><strong>Safari：</strong>webkit</li><li><strong>Opera：</strong>以前是presto内核，现在是Blink</li><li><strong>Edge：</strong>Chromium/Blink</li></ul><h2 id="说说你对HTML5的认识？（是什么，为什么）"><a href="#说说你对HTML5的认识？（是什么，为什么）" class="headerlink" title="说说你对HTML5的认识？（是什么，为什么）"></a>说说你对HTML5的认识？（是什么，为什么）</h2><h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p>HTML5指的是包括HTML、CSS和JavaScript在内的一套技术组合。能够减少网页浏览器对于插件的使用，例如Flash，Sliverlight。并且提供更多能有效加强网络应用的标准集。HTML5是HTML的最新版本。</p><h3 id="二、为什么"><a href="#二、为什么" class="headerlink" title="二、为什么"></a>二、为什么</h3><p>HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能Flash被广泛使用，但安全和稳定堪忧，不适合移动端使用。HTML5增强了浏览器的原生功能，符合HTML5规范的浏览器功能将更加强大，减少了Web应用对插件的依赖，让用户体验更好，让开发更加方便。</p><h2 id="对WEB标准以及W3C的理解与认识？"><a href="#对WEB标准以及W3C的理解与认识？" class="headerlink" title="对WEB标准以及W3C的理解与认识？"></a>对WEB标准以及W3C的理解与认识？</h2><p>HTML（结构），CSS（表现），JavaScript（行为）三部分独立分开，使其更具有模块化。</p><p>W3C对WEB标准提出了规范化的要求：</p><ol><li> <strong>结构要求</strong></li></ol><ul><li> 标签字母要小写</li><li> 标签要闭合</li><li>标签不允许随意嵌套</li></ul><ol start="2"><li><strong>css和js要求</strong><ul><li> 尽量使用外链css样式表和js脚本。使结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户体验。</li><li> 样式尽量少用行间样式表，使结构与表现分离，标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版</li><li> 不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性</li></ul></li></ol><h2 id="HTML全局属性（global-attribute）有哪些？"><a href="#HTML全局属性（global-attribute）有哪些？" class="headerlink" title="HTML全局属性（global attribute）有哪些？"></a>HTML全局属性（global attribute）有哪些？</h2><ul><li><strong>accesskey：</strong>设置访问元素的键盘快捷键</li><li><strong>class：</strong>规定元素的类名</li><li><strong>contenteditable：</strong>规定是否可编辑元素的内容</li><li><strong>contextmenu：</strong>指定一个元素的上下文菜单。当用户右击该元素，出现上下文菜单。</li><li>**data-*：**用于存储页面的自定义数据</li><li><strong>dir：</strong>设置元素中的内容的文本方向</li><li><strong>draggable：</strong>设置元素是否可拖拽</li><li><strong>dropzone：</strong>设置元素拖放类型</li><li><strong>hidden：</strong>规定元素仍未或不在相关</li><li><strong>id：</strong>元素id，文档内唯一</li><li><strong>lang：</strong>元素内容的语言</li><li><strong>spellcheck：</strong>是否启动拼写和语法检查</li><li><strong>style：</strong>行内css样式</li><li><strong>tabindex：</strong>设置元素可以获取焦点，通过tab导航</li><li><strong>title：</strong>规定元素有关的额外信息</li><li><strong>translate：</strong>元素和子孙节点内容是否需要本地化</li></ul><h2 id="HTML5行内元素有哪些，块级元素有哪些？"><a href="#HTML5行内元素有哪些，块级元素有哪些？" class="headerlink" title="HTML5行内元素有哪些，块级元素有哪些？"></a>HTML5行内元素有哪些，块级元素有哪些？</h2><h3 id="一、行内元素"><a href="#一、行内元素" class="headerlink" title="一、行内元素"></a>一、行内元素</h3><p>大多为描述性标记</p><ul><li>span</li><li>a</li><li>br</li><li>b</li><li>strong</li><li>img</li><li>sub</li><li>i</li><li>em</li><li>del</li><li>input</li><li>textarea</li><li>select</li></ul><h3 id="二、块级元素"><a href="#二、块级元素" class="headerlink" title="二、块级元素"></a>二、块级元素</h3><p>大多为结构性标记</p><ul><li>address</li><li>center</li><li>h1</li><li>h2</li><li>h3</li><li>h4</li><li>h5</li><li>h6</li><li>hr</li><li>p</li><li>pre</li><li>blockquote</li><li>marquee</li><li>ul</li><li>ol</li><li>dl</li><li>table</li><li>form</li><li>div</li></ul><h2 id="什么是WebGL，它有什么优点"><a href="#什么是WebGL，它有什么优点" class="headerlink" title="什么是WebGL，它有什么优点?"></a>什么是WebGL，它有什么优点?</h2><p><strong>WebGL：</strong>Web Graphics Library 是一种3D绘图标准，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0 结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，还能创建复杂的导航和数据视觉化。</p><p><strong>优点：</strong> </p><ol><li> 通过HTML脚本本身实现Web交互式三维动画的制作，无需任何浏览器插件支持</li><li> 利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的</li></ol><h2 id="请你描述下cookies，sessionStorage和localStorage的区别？"><a href="#请你描述下cookies，sessionStorage和localStorage的区别？" class="headerlink" title="请你描述下cookies，sessionStorage和localStorage的区别？"></a>请你描述下cookies，sessionStorage和localStorage的区别？</h2><h3 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h3><table><thead><tr><th align="left">特性</th><th>Cookies</th><th>localStorage</th><th align="center">sessionStorage</th><th></th></tr></thead><tbody><tr><td align="left">特性</td><td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookies，默认是关闭浏览器后失效</td><td>除非被清除，否则永久保存</td><td align="center">仅在当前会话下有效，关闭页面或浏览器后被清除</td><td></td></tr><tr><td align="left">存放数据大小</td><td>4K左右</td><td>一般为5MB</td><td align="center">一般为5MB</td><td></td></tr><tr><td align="left">与服务器端通信</td><td>每次都会携带在HTTP头中，如果使用Cookies保存过多数据会带来性能模式</td><td>仅在客户端中保存，不参与和服务器的通信</td><td align="center">仅在客户端中保存，不参与和服务器的通信</td><td></td></tr><tr><td align="left">易用性</td><td>需要程序员自己封装，源生的Cookies接口不友好</td><td>源生接口可以接收，亦可再次封装对Object和Array有更好的支持</td><td align="center">源生接口可以接收，亦可再次封装对Object和Array有更好的支持</td><td></td></tr><tr><td align="left"></td><td></td><td></td><td align="center"></td><td></td></tr></tbody></table><h3 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h3><ul><li>sessionStorage：在不需要和服务器交互的场所，用来存储用户数据之类的，可以在路由页跳转的时候取出更改储存，减少调用接口的次数，减轻服务器压力</li><li>localStorage：会话状态管理，可替换Cookies</li><li>Cookies：会话状态管理、个性化设置、浏览器行为跟踪</li></ul><hr><p>8月16日更新</p><h2 id="说说你对HTML语义化的理解？"><a href="#说说你对HTML语义化的理解？" class="headerlink" title="说说你对HTML语义化的理解？"></a>说说你对HTML语义化的理解？</h2><h3 id="一、什么是HTML语义化"><a href="#一、什么是HTML语义化" class="headerlink" title="一、什么是HTML语义化"></a>一、什么是HTML语义化</h3><p>基本上围绕几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等</p><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p><h3 id="二、为什么要语义化"><a href="#二、为什么要语义化" class="headerlink" title="二、为什么要语义化"></a>二、为什么要语义化</h3><ul><li> 为了在没有CSS的情况下，页面也能呈现出很好的内容结构、代码结构</li><li>用户体验，例如title、alt用于解释名词或解释图片信息、label标签的或用</li><li>有利于SEO和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息（爬虫依赖于标签来确定上下文和各个关键字的权重）</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页</li><li>便于团队开发和维护，语义化更具有可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化</li></ul><h3 id="三、语义化标签"><a href="#三、语义化标签" class="headerlink" title="三、语义化标签"></a>三、语义化标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一套结构完整且独立的内容部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">articel</span>&gt;</span><span class="tag">&lt;/<span class="name">articel</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 主题的附属信息（文章的作者以及信息内容） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 媒体元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span>&gt;</span><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">detail</span>&gt;</span><span class="tag">&lt;/<span class="name">detail</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="link和-import的区别？"><a href="#link和-import的区别？" class="headerlink" title="link和@import的区别？"></a>link和@import的区别？</h2><ul><li>link是XHTML标签，除了加载CSS外，还可以定义<a href="https://baike.baidu.com/item/rss/24470?fr=aladdin">RSS</a>等其他事务；@import属于CSS范畴，只能加载CSS</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后加载</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持</li><li>link支持使用JavaScript控制DOM去改变样式；@import不支持</li></ul><h2 id="说说你对SVG的理解？"><a href="#说说你对SVG的理解？" class="headerlink" title="说说你对SVG的理解？"></a>说说你对SVG的理解？</h2><p>SVG可缩放适量图形是基于可扩展标记语言（XML），用于描述二维矢量图形的一种图形结构。SVG严格遵从XML语法，用文本格式的描述性语言描述图像内容，因此是一种和图像分辨率无关的矢量图形。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>任意缩放，不会破坏图像的清晰度、细节等</li><li>文本独立，SVG中的文字独立于图像，不会有字体的限制，用户系统即便没有安装某一字体，也会看到制作时完全相同的画面</li><li>较小文件，总体来讲，比GIF和JPEG格式文件小很多，因此下载很快</li><li>超强显示效果：边缘清晰，清晰度适合任何屏幕分辨率和打印分辨率</li><li>超级颜色控制：提供1600万种颜色的调色板，支持ICC颜色描述文件标准、RGB、线X填充、渐变和蒙版</li><li>浏览器支持：IE9，火狐，谷歌，Opera和Safari都支持</li></ul><h2 id="说说超链接target属性的取值和作用？"><a href="#说说超链接target属性的取值和作用？" class="headerlink" title="说说超链接target属性的取值和作用？"></a>说说超链接target属性的取值和作用？</h2><p>target这个属性指定链接的页面在浏览器窗口中的打开方式</p><p><strong>参数值：</strong></p><ul><li>_blank：在新浏览器窗口中打开链接文件</li><li>_parent：将链接的文件载入含有该链接框架的父框架集或父窗口中</li><li>_self：在同一框架或窗口中打开所链接的文档</li><li>_top：在当前的整个浏览器窗口中打开所链接的文档</li></ul><h2 id="‘data-‘属性的作用是什么？"><a href="#‘data-‘属性的作用是什么？" class="headerlink" title="‘data-‘属性的作用是什么？"></a>‘data-‘属性的作用是什么？</h2><p>h5新增的前端开发者提供自定义的属性，这些属性集可以通过对象的’dataset’（使用驼峰风格）或’getAttribute’方法获取。</p><h2 id="介绍一下你对浏览器内核的理解？"><a href="#介绍一下你对浏览器内核的理解？" class="headerlink" title="介绍一下你对浏览器内核的理解？"></a>介绍一下你对浏览器内核的理解？</h2><p>主要分成两部分：渲染引擎和JS引擎。</p><p><strong>渲染引擎：</strong></p><p>​        负责取得网页的内容（<strong>HTML、XML、图像等</strong>）、整理讯息（<strong>加入CSS等</strong>），以及计算网页的显示方式，然后会输出至显示器或打印机。</p><p><strong>JS引擎：</strong></p><p>​        解析和执行JavaScript来实现网页的动态效果</p><p>最开始渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。    </p><h2 id="iframe有哪些缺点"><a href="#iframe有哪些缺点" class="headerlink" title="iframe有哪些缺点"></a>iframe有哪些缺点</h2><p>如需使用iframe，最好通过JavaScript动态给iframe添加src属性值</p><ul><li>阻塞主页面的Onload事件</li><li>搜索引擎的检索程序无法解读这个页面，不利于<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132?fromtitle=SEO&fromid=102990">SEO</a></li><li>和主页面共享连接池，而浏览器对相同域的连接有限制，影响页面的并行加载</li></ul><h2 id="Label的作用是什么，是怎么用的？"><a href="#Label的作用是什么，是怎么用的？" class="headerlink" title="Label的作用是什么，是怎么用的？"></a>Label的作用是什么，是怎么用的？</h2><p>label标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p><p><strong>用法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><hr><p>8月18日更新</p><h2 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信"></a>如何实现浏览器内多个标签页之间的通信</h2><ul><li><strong>WebSocket：</strong>需要页面与服务器建立WebSockets连接</li><li><strong>SharedWorker</strong></li><li><strong>LocalStorage：</strong>LocalStorage在一个标签页被添加、修改或删除时，都会触发storage事件，通过另一个标签页监听storage事件，即可得到localStorage存储的值，实现不同标签页之间的通信</li><li><strong>Cookies：</strong>将传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息</li></ul><h2 id="如何在页面上实现一个圆形的可点击区域"><a href="#如何在页面上实现一个圆形的可点击区域" class="headerlink" title="如何在页面上实现一个圆形的可点击区域"></a>如何在页面上实现一个圆形的可点击区域</h2><ul><li><p>使用border-radius</p></li><li><p>map+area（带有可点击区域的图像映射）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;Map&quot;</span> <span class="attr">id</span>=<span class="string">&quot;Map&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;821, 289, 68&quot;</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">area</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>纯js实现，求点不在圆上的简单算法、获取鼠标坐标</p></li></ul><h2 id="如何在页面上画个三角形"><a href="#如何在页面上画个三角形" class="headerlink" title="如何在页面上画个三角形"></a>如何在页面上画个三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: red transparent transparent tansparent;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h2><ul><li>title只是个标题，通常用来定义浏览器标签页的名称，h1表示层次明确的标题，对页面信息的抓取有很大的影响</li><li>strong标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，<b>只是展示强调内容</li><li>i内容展示为斜体，em表示斜体强调的文本</li></ul><h2 id="简述一下src与href的区别"><a href="#简述一下src与href的区别" class="headerlink" title="简述一下src与href的区别"></a>简述一下src与href的区别</h2><p>src用于替换当前元素，href用于当前文档和引用资源之间确立联系</p><p>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片。<strong>当浏览器解析到该元素时，会暂停其他资源的下载和处理，知道将该资源、编译、执行完毕。</strong></p><p>href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，<strong>并行下载资源并且不会停止对当前文档的处理。</strong></p><h2 id="谈谈你对canvas的理解？"><a href="#谈谈你对canvas的理解？" class="headerlink" title="谈谈你对canvas的理解？"></a>谈谈你对canvas的理解？</h2><p>canvas是HTML5新增的HTML5标签与操作canvas的javascript API，它可以实现在网页中完成动态的2D与3D图像技术。标记和SVG以及VML之间的一个重要不同是，有一个基于JavaScript的绘图API，而SVG和VML使用一个XML文档来描述绘图。SVG绘图很容易编辑与生成，但功能明显要弱一些。<strong>canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。</strong></p><h2 id="WebSocket与消息推送"><a href="#WebSocket与消息推送" class="headerlink" title="WebSocket与消息推送?"></a>WebSocket与消息推送?</h2><p>B/S架构的系统多使用HTTP协议</p><p>HTTP协议特点:</p><ul><li>无状态协议</li><li>用于通过Internet发送请求消息和响应消息</li><li>使用端口接收和发送消息,默认为80端口</li></ul><p>双向通信与消息推送:</p><ul><li><strong>轮询：</strong>客户端定时向服务器发送Ajax请求，服务器接到请求后马上但会响应消息并关闭连接</li><li><strong>长轮询：</strong>客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求</li><li><strong>长连接：</strong>在页面中嵌入一个隐藏iframe，将这个隐藏iframe的src属性设为对一个长连接的请求或是xhr请求，服务端就能源源不断地往客户端输入数据</li><li><strong>Flash Socket：</strong>在页面中嵌入一个使用了Socket类的Flash程序JavaScript通过调用此Flash程序提供的Socket接口进行通信，JavaScript在收到服务器端传送的信息后控制页面的显示</li><li><strong>WebSocket：</strong>HTML5开始提供的一种与浏览器与服务器进行全双工通讯的网络技术。依靠这个技术可以实现客户端和服务端的长连接，双向实时通信。</li></ul><h2 id="img的title和alt有什么区别？"><a href="#img的title和alt有什么区别？" class="headerlink" title="img的title和alt有什么区别？"></a>img的title和alt有什么区别？</h2><p>alt用于图片无法加载时显示，title为该属性提供信息，通常当鼠标滑动到元素上显示</p><h2 id="表单的基本组成部分有哪些，表单的主要用途是什么？"><a href="#表单的基本组成部分有哪些，表单的主要用途是什么？" class="headerlink" title="表单的基本组成部分有哪些，表单的主要用途是什么？"></a>表单的基本组成部分有哪些，表单的主要用途是什么？</h2><p><strong>主要用途：</strong>负责数据采集的功能，和向服务器传送数据</p><p><strong>组成：</strong>表单标签、表单域、表单按钮</p><ul><li><strong>表单标签：</strong>包含了处理表单数据所用的<a href="https://baike.baidu.com/item/CGI/607810?fr=aladdin&fromid=6717913&fromtitle=%EF%BC%A3%EF%BC%A7%EF%BC%A9">CGI</a>程序的URL，以及表单提交到服务器的方法</li><li><strong>表单域：</strong>包含了文本框、密码框、隐藏框、多行文本框、复选框、单选框、下拉选择框和文件上传框等</li><li><strong>表单按钮：</strong>包括提交按钮、复位按钮和一般按钮，用于将数据传送到服务器上的<a href="https://baike.baidu.com/item/CGI/607810?fr=aladdin&fromid=6717913&fromtitle=%EF%BC%A3%EF%BC%A7%EF%BC%A9">CGI</a>脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作</li></ul><h2 id="表单提交中GET和POST方式的区别？"><a href="#表单提交中GET和POST方式的区别？" class="headerlink" title="表单提交中GET和POST方式的区别？"></a>表单提交中GET和POST方式的区别？</h2><ul><li>get是从服务器上获取数据，post是向服务器传送数据</li><li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址，用户看不到这个过程</li><li>对于get方式，服务端用Request.QueryString接收，post方式，服务端用Request.Form获取提交的数据</li><li>get传送的数据量较少，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，<a href="https://baike.baidu.com/item/IIS%207.0/5826890?fr=aladdin">IIS</a>4最大量为80KB，<a href="https://baike.baidu.com/item/IIS%207.0/5826890?fr=aladdin">IIS</a>5中为100KB</li><li>get安全性低，post安全性高</li></ul><h2 id="HTML5标准提供了哪些新的API？"><a href="#HTML5标准提供了哪些新的API？" class="headerlink" title="HTML5标准提供了哪些新的API？"></a>HTML5标准提供了哪些新的API？</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStream">Media API</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/TextTrack">Text Track API</a></li><li><a href="https://www.cnblogs.com/blackbird/archive/2012/06/12/2546751.html">Application Cache API</a></li><li><a href="https://blog.csdn.net/anitak/article/details/52503578">User Interaction</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer">Data Transfer API</a></li><li>Command API</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Constraint_validation">Constraint Validation API</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">History API</a></li></ul><h2 id="HTML5应用程序缓存和浏览器缓存有什么区别？"><a href="#HTML5应用程序缓存和浏览器缓存有什么区别？" class="headerlink" title="HTML5应用程序缓存和浏览器缓存有什么区别？"></a>HTML5应用程序缓存和浏览器缓存有什么区别？</h2><p>应用程序缓存是HTML5的重要特性之一，提供了离线使用的功能，让应用程序可以获得本地的网站内容，例如HTML、CSS、图片以及JavaScript。这个特性可以提高网站性能，它的实现借助于manifest。与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;example.appcache&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="新的HTML5文档类型和字符集是？"><a href="#新的HTML5文档类型和字符集是？" class="headerlink" title="新的HTML5文档类型和字符集是？"></a>新的HTML5文档类型和字符集是？</h2><p>文档类型：<code>&lt;!doctype html&gt;</code></p><p>使用UTF-8编码示例：<meta charset="UTF-8"></p><hr><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客系统——使用Volantis主题</title>
      <link href="/2021/08/14/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Volantis%E4%B8%BB%E9%A2%98/"/>
      <url>/2021/08/14/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Volantis%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><h3 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># blog/_config.yml文件中修改</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">volantis</span></span><br></pre></td></tr></table></figure><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 终端中输入</span><br><span class="line">npm i hexo-theme-volantis</span><br></pre></td></tr></table></figure><h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><h3 id="网站标题"><a href="#网站标题" class="headerlink" title="网站标题"></a>网站标题</h3><p><code>blog/_config.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站标题</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Chaos4Yarn的学习站</span></span><br></pre></td></tr></table></figure><h3 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h3><p><code>blog/_config.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站标题</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico</span></span><br></pre></td></tr></table></figure><h3 id="多语言设置"><a href="#多语言设置" class="headerlink" title="多语言设置"></a>多语言设置</h3><p><code>blog/_config.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语言</span></span><br><span class="line"><span class="attr">language:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="string">zh-CN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">en</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">zh-HK</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">zh-TW</span></span><br></pre></td></tr></table></figure><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="创建主题配置文件"><a href="#创建主题配置文件" class="headerlink" title="创建主题配置文件"></a>创建主题配置文件</h3><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><p>在博客根目录的_config.yml文件旁新建一个文件: _config.volantis.yml，这个文件中的配置信息优先级高于主题文件夹中的配置文件。</p><h4 id="覆盖自定义配置"><a href="#覆盖自定义配置" class="headerlink" title="覆盖自定义配置"></a>覆盖自定义配置</h4><p><code>blog/_config.volantis.yml</code></p><h5 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置导航栏</span></span><br><span class="line"><span class="attr">navbar:</span></span><br><span class="line">  <span class="comment"># 导航栏显示方式</span></span><br><span class="line">  <span class="attr">visiable:</span> <span class="string">auto</span> <span class="comment"># always, auto</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># choose [img] or [icon + title]</span></span><br><span class="line">    <span class="attr">img:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">学习站</span></span><br><span class="line">  <span class="comment"># 导航栏选项</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">博客</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-rss</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">归档</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">更多</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-ellipsis-v</span></span><br><span class="line">      <span class="attr">rows:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">友链</span></span><br><span class="line">          <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">friends/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">          <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-info-circle</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">about/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hr</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">背景音乐</span></span><br><span class="line">          <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-compact-disc</span></span><br><span class="line">  <span class="comment"># 导航栏显示搜索框</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br></pre></td></tr></table></figure><h5 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置搜索引擎</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">hexo</span>  <span class="comment"># hexo, google, algolia, azure, baidu</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2.6.4/js/search.js</span></span><br><span class="line">  <span class="attr">google:</span></span><br><span class="line">    <span class="attr">apiKey:</span></span><br><span class="line">    <span class="attr">engineId:</span></span><br><span class="line">  <span class="attr">algolia:</span></span><br><span class="line">    <span class="attr">applicationID:</span></span><br><span class="line">    <span class="attr">apiKey:</span></span><br><span class="line">    <span class="attr">indexName:</span></span><br><span class="line">  <span class="attr">azure:</span></span><br><span class="line">    <span class="attr">serviceName:</span></span><br><span class="line">    <span class="attr">indexName:</span></span><br><span class="line">    <span class="attr">queryKey:</span></span><br><span class="line">  <span class="attr">baidu:</span></span><br><span class="line">    <span class="string">apiId</span></span><br></pre></td></tr></table></figure><h5 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置封面</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># 封面名字</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&#x27;Chaos4Yarn&#x27;</span></span><br><span class="line">  <span class="comment"># 封面子标题</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;学习站&#x27;</span></span><br><span class="line">  <span class="comment"># 封面背景图</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">https://www.ymq19.cn/blog/cover.jpg</span></span><br><span class="line">  <span class="comment"># 封面中下区的选项栏</span></span><br><span class="line">  <span class="attr">features:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">博客</span></span><br><span class="line">      <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">      <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c2.svg</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/categories/</span></span><br><span class="line">      <span class="attr">target:</span> <span class="string">_self</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5d2.svg</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/tags/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">归档</span></span><br><span class="line">      <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">源码</span></span><br><span class="line">      <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f9ec.svg</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/ymq19/ymq19.github.io</span></span><br><span class="line">      <span class="attr">target:</span> <span class="string">_self</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="文章布局"><a href="#文章布局" class="headerlink" title="文章布局"></a>文章布局</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章布局</span></span><br><span class="line"><span class="attr">article:</span></span><br><span class="line">  <span class="comment"># 文章列表页面的文章卡片布局方案</span></span><br><span class="line">  <span class="attr">preview:</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">landscape</span> <span class="comment"># landscape</span></span><br><span class="line">    <span class="comment"># pin icon for post</span></span><br><span class="line">    <span class="attr">pin_icon:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg</span></span><br><span class="line">    <span class="comment"># auto generate title if not exist</span></span><br><span class="line">    <span class="attr">auto_title:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># auto generate excerpt if not exist</span></span><br><span class="line">    <span class="attr">auto_excerpt:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># show split line or not</span></span><br><span class="line">    <span class="attr">line_style:</span> <span class="string">solid</span> <span class="comment"># hidden, solid, dashed, dotted</span></span><br><span class="line">    <span class="comment"># show readmore button</span></span><br><span class="line">    <span class="attr">readmore:</span> <span class="string">auto</span> <span class="comment"># auto, always</span></span><br><span class="line">  <span class="comment"># 文章详情页面的文章卡片本体布局方案</span></span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="comment"># meta library</span></span><br><span class="line">    <span class="attr">meta_library:</span></span><br><span class="line">      <span class="comment"># 默认文章作者（可在 front-matter 中覆盖）</span></span><br><span class="line">      <span class="attr">author:</span></span><br><span class="line">        <span class="attr">avatar:</span> <span class="string">https://www.ymq19.cn/blog/ai.jpg</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Chaos4Yarn</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">updated:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-edit</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;更新于：&#x27;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;ll&#x27;</span> <span class="comment"># 日期格式 http://momentjs.com/docs/</span></span><br></pre></td></tr></table></figure><h5 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置侧边栏</span></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># 在页面中显示</span></span><br><span class="line">  <span class="attr">for_page:</span> [<span class="string">blogger</span>, <span class="string">post</span>, <span class="string">category</span>, <span class="string">tagcloud</span>]</span><br><span class="line">  <span class="comment"># 在文章页显示</span></span><br><span class="line">  <span class="attr">for_post:</span> [<span class="string">toc</span>]</span><br><span class="line">  <span class="attr">widget_library:</span></span><br><span class="line">  <span class="comment"># 作者信息</span></span><br><span class="line">    <span class="attr">blogger:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">blogger</span></span><br><span class="line">      <span class="attr">display:</span> [ <span class="string">desktop</span>, <span class="string">mobile</span> ] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://www.ymq19.cn/blog/cat.jpeg</span></span><br><span class="line">      <span class="attr">shape:</span> <span class="string">circle</span> <span class="comment"># circle, rectangle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/about/</span></span><br><span class="line">      <span class="attr">title:</span></span><br><span class="line">      <span class="attr">subtitle:</span></span><br><span class="line">      <span class="attr">jinrishici:</span> <span class="literal">true</span> <span class="comment"># Poetry Today. You can set a string, and it will be displayed when loading fails.</span></span><br><span class="line">      <span class="attr">social:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 文章索引</span></span><br><span class="line">    <span class="attr">toc:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">toc</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-list</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">本文目录</span></span><br><span class="line">      <span class="attr">list_number:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">min_depth:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">max_depth:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># 按目录对文章进行分类</span></span><br><span class="line">    <span class="attr">category:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">category</span></span><br><span class="line">      <span class="attr">display:</span> [ <span class="string">desktop</span> ] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/categories/</span></span><br><span class="line">    <span class="comment"># tagcloud widget</span></span><br><span class="line">    <span class="comment"># 热门标签，按标签对文章分类</span></span><br><span class="line">    <span class="attr">tagcloud:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">tagcloud</span></span><br><span class="line">      <span class="attr">display:</span> [ <span class="string">desktop</span>, <span class="string">mobile</span> ] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">热门标签</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/tags/</span></span><br><span class="line">      <span class="attr">min_font:</span> <span class="number">14</span></span><br><span class="line">      <span class="attr">max_font:</span> <span class="number">24</span></span><br><span class="line">      <span class="attr">color:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">start_color:</span> <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      <span class="attr">end_color:</span> <span class="string">&#x27;#555&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="页脚"><a href="#页脚" class="headerlink" title="页脚"></a>页脚</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置页脚</span></span><br><span class="line"><span class="attr">site_footer:</span></span><br><span class="line">  <span class="comment"># aplayer: 音乐播放器，social：社交关系，source：来源，analysis：网站访问分析，copyright：版权</span></span><br><span class="line">  <span class="attr">layout:</span> [<span class="string">aplayer</span>, <span class="string">social</span>, <span class="string">source</span>, <span class="string">analytics</span>, <span class="string">copyright</span>]</span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">&#x27;[Copyright © 2021-2021 Chaos4Yarn](/)&#x27;</span></span><br><span class="line">  <span class="attr">social:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-rss</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-envelope</span></span><br><span class="line">      <span class="attr">url:</span> <span class="number">1976583473</span><span class="string">@qq.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/ymq19</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-headphones-alt</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://music.163.com/#/user/home?id=301256444</span></span><br></pre></td></tr></table></figure><h5 id="全局CSS"><a href="#全局CSS" class="headerlink" title="全局CSS"></a>全局CSS</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 页面CSS设置</span></span><br><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="attr">max_width:</span> <span class="string">1080px</span> <span class="comment"># Sum of body width and sidebar width</span></span><br><span class="line">  <span class="attr">font_smoothing:</span> <span class="literal">true</span> <span class="comment"># font-smoothing for webkit</span></span><br><span class="line">  <span class="attr">cursor:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sidebar:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>]</span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br></pre></td></tr></table></figure><h5 id="右键菜单"><a href="#右键菜单" class="headerlink" title="右键菜单"></a>右键菜单</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义右键菜单</span></span><br><span class="line"><span class="attr">rightmenu:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">faicon:</span> <span class="string">fa</span>              <span class="comment"># 公共图标类型 fa fal fas fad</span></span><br><span class="line">  <span class="comment"># hr: 分割线, music: 音乐控制器</span></span><br><span class="line">  <span class="attr">layout:</span> [<span class="string">home</span>, <span class="string">hr</span>, <span class="string">help</span>, <span class="string">hr</span>, <span class="string">source_docs</span>, <span class="string">source_theme</span>, <span class="string">hr</span>, <span class="string">print</span>, <span class="string">darkmode</span>, <span class="string">music</span>]</span><br><span class="line">  <span class="comment">### 可选功能项 ###</span></span><br><span class="line">  <span class="attr">print:</span>                  <span class="comment"># 只有文章页才允许自定义打印</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">打印页面</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-print</span></span><br><span class="line">    <span class="attr">defaultStyles:</span> <span class="literal">true</span>   <span class="comment"># 是否使用预制的打印样式</span></span><br><span class="line">    <span class="comment"># js:                 # 自定义 js ，可用于修饰打印样式~， 右键剔除了对 Jquery 的依赖，所以此处你只能使用原生 js</span></span><br><span class="line">    <span class="comment">#  - document.querySelector(&#x27;article#comments&#x27;).remove()  # 移除评论</span></span><br><span class="line">  <span class="attr">darkmode:</span>        <span class="comment"># 需开启 plugins.darkmodejs</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">暗黑模式</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-moon</span></span><br><span class="line">  <span class="attr">customPicUrl:</span>    <span class="comment"># 右键的图片复制：只有 Chrome 支持，且只支持 PNG 格式的图片。</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment"># 如果使用了对象存储且开启了自适应 Webp，那么可以提供额外的链接用以替换图片的访问地址</span></span><br><span class="line">    <span class="attr">old:</span> <span class="comment">#https://static.inkss.cn/img/article/</span></span><br><span class="line">    <span class="attr">new:</span> <span class="comment">#https://cdn.jsdelivr.net/gh/inkss/inkss-cdn@master/img/article/</span></span><br><span class="line">  <span class="attr">help:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">常见问题</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-question</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://volantis.js.org/faqs/</span></span><br><span class="line">  <span class="attr">source_docs:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">本站源码</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-code-branch</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://github.com/ymq19/ymq19.github.io</span></span><br><span class="line">  <span class="attr">source_theme:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">主题源码</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-code-branch</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/hexo-theme-volantis/</span></span><br></pre></td></tr></table></figure><h5 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第三方插件</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="comment"># 剪切板</span></span><br><span class="line">  <span class="attr">clipboard:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 字数统计</span></span><br><span class="line">  <span class="attr">wordcount:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 视觉滚动效果</span></span><br><span class="line">  <span class="attr">parallax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">highlightjs:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Please set hexo.config.highlight.enable = false !!!</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js</span></span><br><span class="line">    <span class="attr">css:</span> <span class="string">https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css</span></span><br><span class="line">  <span class="comment"># 图片懒加载</span></span><br><span class="line">  <span class="comment"># https://www.npmjs.com/package/vanilla-lazyload</span></span><br><span class="line">  <span class="attr">lazyload:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js</span></span><br><span class="line">    <span class="attr">onlypost:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">loadingImg:</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg</span></span><br><span class="line">    <span class="attr">blurIn:</span> <span class="literal">true</span> <span class="comment"># 模糊加载效果 （loadingImg为空时有效）</span></span><br><span class="line">  <span class="comment"># 音乐播放器</span></span><br><span class="line">  <span class="attr">aplayer:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">js:</span></span><br><span class="line">      <span class="attr">aplayer:</span> <span class="string">https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js</span></span><br><span class="line">      <span class="attr">meting:</span> <span class="string">https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js</span></span><br><span class="line">    <span class="comment"># Required</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">netease</span>   <span class="comment"># netease, tencent, kugou, xiami, baidu</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">playlist</span>    <span class="comment"># song, playlist, album, search, artist</span></span><br><span class="line">    <span class="comment"># 歌单id，需公开，隐私歌单无效</span></span><br><span class="line">    <span class="attr">id:</span> <span class="number">6917175772</span>    <span class="comment"># song id / playlist id / album id / search keyword</span></span><br><span class="line">    <span class="comment"># Optional</span></span><br><span class="line">    <span class="attr">fixed:</span> <span class="literal">false</span>      <span class="comment"># enable fixed mode</span></span><br><span class="line">    <span class="attr">theme:</span> <span class="string">&#x27;#1BCDFC&#x27;</span>  <span class="comment"># main color</span></span><br><span class="line">    <span class="attr">autoplay:</span> <span class="literal">false</span>   <span class="comment"># audio autoplay</span></span><br><span class="line">    <span class="attr">order:</span> <span class="string">list</span>       <span class="comment"># player play order, values: &#x27;list&#x27;, &#x27;random&#x27;</span></span><br><span class="line">    <span class="attr">loop:</span> <span class="string">all</span>         <span class="comment"># player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27;</span></span><br><span class="line">    <span class="attr">volume:</span> <span class="number">0.7</span>       <span class="comment"># default volume, notice that player will remember user setting, default volume will not work after user set volume themselves</span></span><br><span class="line">    <span class="attr">list_max_height:</span> <span class="string">320px</span> <span class="comment"># list max height</span></span><br><span class="line">    <span class="attr">list_folded:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">message:</span> <span class="comment"># 音乐通知，播放、暂停、失败 时的图标</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">play:</span> <span class="string">fas</span> <span class="string">fa-play</span></span><br><span class="line">      <span class="attr">pause:</span> <span class="string">fas</span> <span class="string">fa-pause</span></span><br><span class="line">  <span class="comment"># 暗黑模式</span></span><br><span class="line">  <span class="attr">darkmodejs:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 网站统计</span></span><br><span class="line">  <span class="attr">analytics:</span></span><br><span class="line">    <span class="attr">busuanzi:</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js</span></span><br><span class="line">    <span class="attr">leancloud:</span></span><br><span class="line">      <span class="attr">app_id:</span> <span class="string">GCYDRKI6XRkyC7EuEhJv90ia-MdYXbMMI</span></span><br><span class="line">      <span class="attr">app_key:</span> <span class="string">4xKBXGBj6BgecU62vff5rJHs</span></span><br><span class="line">      <span class="attr">custom_api_server:</span> <span class="comment"># 一般不需要写，除非自定义了 API Server</span></span><br></pre></td></tr></table></figure><h2 id="创建博文"><a href="#创建博文" class="headerlink" title="创建博文"></a>创建博文</h2><h3 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 终端中输入，&lt;<span class="built_in">title</span>&gt;使用真正的文章名</span><br><span class="line">hexo new post &lt;<span class="built_in">title</span>&gt;</span><br><span class="line"></span><br><span class="line"># 创建成功，会在_post文件下显示新建的<span class="built_in">md</span>文件，在头部可修改标题、分类及标签，例如：</span><br><span class="line">---</span><br><span class="line"><span class="function">title: <span class="title">XXX</span></span></span><br><span class="line"><span class="function"><span class="title">date</span>: 2099-08-15 20:20:20</span></span><br><span class="line"><span class="function"><span class="title">categories</span>: 其他</span></span><br><span class="line"><span class="function"><span class="title">tags</span>:</span></span><br><span class="line"><span class="function">  - <span class="title">hexo</span></span></span><br><span class="line"><span class="function">---</span></span><br></pre></td></tr></table></figure><h3 id="上传部署"><a href="#上传部署" class="headerlink" title="上传部署"></a>上传部署</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="built_in">cmd</span>命令</span><br><span class="line">hexo clean /回车</span><br><span class="line">hexo g /回车</span><br><span class="line">hexo d /回车</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/13/hello-world/"/>
      <url>/2021/08/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> welcome </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
